{"mappings":"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","sources":["node_modules/@swc/helpers/src/_async_to_generator.js","node_modules/@swc/helpers/src/_define_property.js","src/scripts/classes/ContextChecks.js","src/scripts/classes/StackingContext.js","src/scripts/classes/ContextsContainer.js","src/scripts/utils/DOMTraversal.js","node_modules/@andreadev/bg-script/src/CustomEventTarget.js","node_modules/@andreadev/bg-script/src/Connection.js","node_modules/@andreadev/bg-script/src/Errors.js","node_modules/@andreadev/bg-script/index-modules.js","node_modules/@andreadev/bg-script/src/BackgroundScript.js","src/scripts/content.js","src/scripts/utils/utils.js"],"sourcesContent":["function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n","/**\n * Creates a new check to do on a DOM element to make sure if it is a stacking context.\n * \n * @property {string} description This text will be shown in the devtools to explain why the element is a stacking context.\n * @property {function} callback To this callback will be passed the DOM element and its computed style. It must return \n *                                  wether or not the check is passed.\n */\nexport class ContextCheck {\n\n    description = \"\";\n    callback = null;\n\n    constructor(description, callback) {\n        if (!description || !callback) {\n            throw \"Both a description and a callback are needed to create a new context check\"\n        }\n        this.description = description;\n        this.callback = callback;\n    }\n\n    /**\n     * Executes the check callback on the element passed as a parameter. Returns wether or not this Node creates a static context.\n     * \n     * @param {Node} element The element to check.\n     * @param {CSSStyleDeclaration} elementStyle Optional. The element computed styles (it will be loaded if not passed) \n     * @returns {boolean} \n     */\n    exec(element, elementStyle) {\n        if (!element) throw \"Cannot execute a check without an element\";\n        if (!elementStyle) {\n            elementStyle = window.getComputedStyle(element);\n        }\n\n        return this.callback(element, elementStyle);\n    }\n\n}\n\n/* \n * List of checks to do on the element in order for it to create a new stacking context.\n * These checks are based on this MDN article: \n * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n */\n\nexport const positionFixedSticky = new ContextCheck(\n    \"The element position has the value 'fixed' or 'sticky'\",\n    (element, styles) => {\n        if (styles.position == \"fixed\" ||\n            styles.position == \"sticky\")\n        {\n            return true;\n        }\n        return false;\n    }\n);\n\nexport const zIndexWithPosition = new ContextCheck(\n    \"The element has a z-index set and the position is not 'static'\",\n    (element, styles) => {\n        if (styles.position !== \"static\" &&\n            styles.zIndex !== \"auto\")\n        {\n            return true;\n        }\n        return false;\n    }\n);\n\nexport const notFullOpacity = new ContextCheck(\n    \"The element has an opacity value smaller than 1\",\n    (element, styles) => {\n\n        if (styles.opacity == \"auto\") return false;\n        \n        let opacity = parseFloat(styles.opacity);\n        \n        if (isNaN(opacity) || opacity == 1) return false;\n        \n        return true;\n    }\n);\n\nexport const mixBlendMode = new ContextCheck(\n    \"The element has a non-default mix blend mode value\",\n    (element, styles) => {\n        if (styles.mixBlendMode !== \"normal\") {\n            return true;\n        }\n        return false;\n    }\n);\n\nexport const notNoneProperties = new ContextCheck(\n    \"The element has one of the following properties set: transform, filter, perspective, clip-path, mask, maskImage, maskBorder\",\n    (element, styles) => {\n        let toCheck = [styles.transform, styles.filter, styles.perspective, styles.clipPath, styles.mask, styles.maskImage, styles.maskBorder];\n        return toCheck.some( (prop) => prop !== undefined && prop !== \"none\" );\n    }\n);\n\nexport const isolationSet = new ContextCheck(\n    \"The element has the isolation property set to 'isolate'\",\n    (element, styles) => styles.isolation == \"isolate\"\n);\n\nexport const webkitOverflowScrolling = new ContextCheck(\n    \"The element has the webkit-overflow-scrolling property set to 'touch'\",\n    (element, styles) => styles.webkitOverflowScrolling == \"touch\"\n);\n\nexport const willChange = new ContextCheck(\n    \"The element has a will-change value with a property that will create a context when its value is not the default one\",\n    (element, styles) => {\n        let toCheck = [\"mix-blend-mode\", \"transform\", \"filter\", \"perspective\", \"clip-path\", \"mask\", \"mask-image\", \"mask-border\"]\n        return toCheck.some( (prop) => styles.willChange.includes(prop) );\n    }\n);\n\nexport const containValue = new ContextCheck(\n    \"The element has a contain value that includes one of the following: layout, paint (or a composite value like 'strict' or 'content')\",\n    (element, styles) => {\n        let toCheck = [\"layout\", \"paint\", \"strict\", \"content\"];\n        return toCheck.some( (prop) => styles.contain.includes(prop) );\n    }\n);\n\nexport const flexChildWithZIndex = new ContextCheck(\n    \"This element is a child of a flex container and has a z-index set\",\n    (element, styles) => {\n        if (element.parentElement) {\n            let parentStyles = window.getComputedStyle(element.parentElement);\n\n            if (parentStyles.display == \"flex\" && styles.zIndex !== \"auto\") {\n                return true;\n            }\n        }\n        return false;\n    }\n);\n\nexport const gridChildWithZIndex = new ContextCheck(\n    \"This element is a child of a grid container and has a z-index set\",\n    (element, styles) => {\n        if (element.parentElement) {\n            let parentStyles = window.getComputedStyle(element.parentElement);\n\n            if (parentStyles.display == \"grid\" && styles.zIndex !== \"auto\") {\n                return true;\n            }\n        }\n        return false;\n    }\n);\n\n/**\n * A list of checks that will be fired on the elements.\n */\nexport const activeChecks = [\n    positionFixedSticky,\n    zIndexWithPosition,\n    notFullOpacity,\n    mixBlendMode,\n    notNoneProperties,\n    isolationSet,\n    webkitOverflowScrolling,\n    willChange,\n    containValue,\n    flexChildWithZIndex,\n    gridChildWithZIndex\n];","/**\n * This class will be used to represent a static context.\n * \n * @property {number} id\n * @property {StackingContext} parent The parent static context.\n * @property {Array<StackingContext>} children The static context children.\n * @property {Node} element The element that is creating the static context.\n * @property {Node} isInIframe Variable to check if this stacking context is inside an iframe.\n * @property {Node} frame The node that function as the frame for this context element, it might be undefined for the top frame or an iframe element.\n * @property {Array<string>} passedChecks A list of strings that enumerates all the reason why this static context has been created.\n */\nclass StackingContext {\n    \n    id = null;\n    parent = null;\n    children = [];\n    element = null;\n\n    passedChecks = []\n\n    /**\n     * Creates a new Stacking Context object\n     * \n     * @param {Node} element \n     * @param {boolean} isInIframe \n     * @param {Node} frame \n     * @param {StackingContext} parentContext \n     * @param {Array<string>} passedChecks \n     */\n    constructor(element, isInIframe, frame=null, parentContext, passedChecks = []) {\n        this.element = element;\n        this.isInIframe = isInIframe ?? false;\n        this.frame = frame;\n        this.parent = parentContext ?? null;\n        this.passedChecks = passedChecks;\n    }\n\n    /**\n     * Adds a static context as a children of this context\n     * \n     * @param {StackingContext} context\n     */\n    addChild(context) {\n        this.children.push(context);\n    }\n\n    /**\n     * This will convert a stacking context to a JSON-friendly object in order to pass it to the background script and the devtools panel and sidebar.\n     * \n     * @returns The JSON-friendly static context representation\n     */\n    toJSON() {\n        let parentId = this.parent?.id ?? null;\n        let childrenIds = this.children.map( (child) => child.id );\n\n        let classes = [];\n        if (this.element?.classList?.length > 0) {\n            classes = [...this.element.classList];\n        }\n\n        let allElements = Array.from(document.getElementsByTagName('*'));\n        let elementIndex = (this.element) ? allElements.indexOf(this.element) : null;\n\n        let elementStyles = window.getComputedStyle(this.element);\n\n        let elementDescription = {\n            tagName: this.element?.tagName?.toLowerCase() ?? \"document\",\n            id: this.element?.id ?? \"\",\n            classes,\n            index: (elementIndex >= 0) ? elementIndex : null,\n            styles: {\n                zIndex: elementStyles.zIndex,\n                position: elementStyles.position\n            }\n        }\n\n        return {\n            id: this.id,\n            parent: parentId,\n            children: childrenIds,\n            element: elementDescription,\n            passedChecks: this.passedChecks,\n            isInIframe: this.isInIframe\n        };\n    }\n}\n\nexport default StackingContext;","import StackingContext from './StackingContext';\r\n\r\n/**\r\n * Class to represent a document container or an iframe. It should just be a wrapper around contexts\r\n * \r\n * @class\r\n * @extends StackingContext\r\n * @property {string} name\r\n * @property {string} type Makes it easy to tell containers apart from normal stacking contexts\r\n */\r\n\r\nclass ContextsContainer extends StackingContext {\r\n    \r\n    name = \"\";\r\n    type = \"container\";\r\n\r\n    /**\r\n     * Creates a new ContextsContainer\r\n     * \r\n     * @param {string} name The container name\r\n     * @param {Node} element The element related to this container (documentElement)\r\n     * @param {boolean} isInIframe (only for superclass usage)\r\n     * @param {Node} frame The iframe that contains this element\r\n     * @param {StackingContext} parent The parent stacking context (or container)\r\n     */\r\n    constructor(name, element=null, isInIframe, frame=null, parent=null) {\r\n        super(element, isInIframe, frame, parent);\r\n\r\n        if (!name) throw \"The container must have a name\";\r\n\r\n        this.name = name;\r\n    }\r\n\r\n    /**\r\n     * @returns A JSON-friendly object to represent this container\r\n     */\r\n    toJSON() {\r\n        return {\r\n            id: this.id,\r\n            type: \"container\",\r\n            name: this.name,\r\n            children: this.children.map((c) => c.id),\r\n            parent: this.parent?.id\r\n        };\r\n    }\r\n}\r\n\r\nexport default ContextsContainer;","import { activeChecks } from '../classes/ContextChecks.js';\nimport StackingContext from '../classes/StackingContext.js';\nimport ContextsContainer from '../classes/ContextsContainer';\n\nlet allContexts = null;\n\n/**\n * Utility method to traverse a DOM element and check if it's a stacking context. It's recursive and\n * will traverse all the children down the tree.\n * \n * @param {Node} element The element to traverse\n * @param {StackingContext} parentContext The parent context\n * @param {boolean} isInIframe True if we are traversing an iframe\n * @param {Object} frame The current frame (may be undefined or an iframe element).\n */\nfunction traverse(element, parentContext, isInIframe=false, frame) {\n    let context = null;\n\n    let passedChecks = getPassedChecks(element);\n    if (passedChecks.length > 0) {\n        context = new StackingContext(element, isInIframe, frame, parentContext, passedChecks);\n        parentContext.addChild(context);\n        let id = allContexts.push(context);\n        context.id = id - 1; // This will help us referring to this context from other scripts\n        \n        // set the new context as the parent for this element children\n        parentContext = context;\n    }\n    \n    for (let child of element.children) {\n        if (element.nodeType == Node.ELEMENT_NODE) {\n            // We need to pass down the \"IsInIframe\" and \"frame\"\n            traverse(child, parentContext, isInIframe,  frame);\n        }\n    }\n\n    // If element is a traversable iframe...\n    if ( isTraversableIframe(element) ) {\n        // Get the client rect to pass the relative position of the iframe in respect to the top window\n        let iframeDoc = element.contentDocument;\n\n        // Start traversing its documentElement\n        let container = new ContextsContainer(\"#document (iframe)\", iframeDoc.documentElement, isInIframe, element, parentContext);\n        parentContext.addChild(container);\n        let id = allContexts.push(container);\n        container.id = id - 1;\n\n        traverse(\n            iframeDoc.body,\n            container,\n            true,\n            element\n        );\n    }\n    // Check if the element contains an open shadow DOM\n    else if ( hasTraversableShadowDOM(element) ) {\n        let shadowRoot = element.shadowRoot;\n\n        // Shadow roots can't be a container because they are not taken into consideration for stacking contexts\n\n        for (let child of shadowRoot.children) {\n            if (element.nodeType == Node.ELEMENT_NODE) {\n                traverse(child, parentContext, true, frame);\n            }\n        }\n    }\n}\n\n/**\n * Check if an element is an iframe that exposes its content to javascript\n * \n * @param {Node} element The element to be checked\n * @returns {boolean}\n */\nfunction isTraversableIframe(element) {\n    return element.children.length == 0 &&\n        element.tagName === \"IFRAME\" &&\n        element.contentDocument?.documentElement;\n}\n\n/**\n * Check whether or not this element has an open shadow DOM\n * \n * @param {Node} element The element to be checked\n * @returns {boolean}\n */\nfunction hasTraversableShadowDOM(element) {\n    return element.shadowRoot?.mode == \"open\";\n}\n\n/**\n * Check if an element is a stacking context and returns a list of passed checks.\n * \n * @param {Node} element The DOM element to check for a stacking context\n * @returns \n */\nexport function getPassedChecks(element) {\n    let styles = window.getComputedStyle(element);\n    let passed = [];\n\n    for (let check of activeChecks) {\n        if (check.exec(element, styles)) {\n            passed.push(check.description);\n        }\n    }\n\n    return passed;\n}\n\n/**\n * Start traversing the DOM from the documentElement and extracts all the stacking contexts in the page.\n * \n * @returns {Array} Returns an array with two elements: the root context and a list of all contexts.\n */\nexport function getContextsFromPage() {\n    let rootContainer = new ContextsContainer(\"#document\", document.documentElement, false);\n    rootContainer.id = 0;\n    allContexts = [rootContainer];\n\n    traverse(document.body, rootContainer);\n\n    return [rootContainer, allContexts];\n}\n\nexport default {\n    getPassedChecks,\n    getContextsFromPage\n};","class CustomEventTarget {\r\n    \r\n    constructor () {\r\n        this.listeners = new Map(); // event --> listeners\r\n    }\r\n\r\n    addListener(event, callback) {\r\n        if (typeof(callback) !== \"function\") throw \"The callback must be a function\";\r\n\r\n        let callbacksList = this.listeners.get(event);\r\n\r\n        if (!callbacksList) {\r\n            this.listeners.set(event, [callback]);\r\n            return;\r\n        }\r\n\r\n        callbacksList.push(callback);\r\n    }\r\n\r\n    removeListener(event, callback) {\r\n        let callbacksList = this.listeners.get(event);\r\n\r\n        if (!callbacksList) return;\r\n\r\n        let callbackIndex = callbacksList.indexOf(callback);\r\n\r\n        if (callbackIndex < 0) return;\r\n\r\n        callbacksList.splice(callbackIndex, 1);\r\n    }\r\n\r\n    fireEvent(event, details = {}) {\r\n        let callbacksList = this.listeners.get(event);\r\n\r\n        if (!callbacksList) return;\r\n\r\n        for (let callback of callbacksList) {\r\n            callback(details);\r\n        }\r\n    }\r\n}\r\n\r\nexport default CustomEventTarget;","import CustomEventTarget from './CustomEventTarget.js';\r\n\r\n/** @constant {string} CONNECTION_PREFIX A prefix added to the connection port name to recognize a connection from within the bgscript library. */\r\nexport const CONNECTION_PREFIX = \"bgscript-\";\r\n\r\n/** @constant {string} CONNECTION_PREFIX_NOTAB A prefix added to the connection port name to recognize an internal connection to a script that is not associated with any chrome tab. */\r\nexport const CONNECTION_PREFIX_NOTAB = \"bgscript.notab-\";\r\n\r\n/** @constant {object} MESSAGE_TYPES It contains all the message types values to be used in the code */\r\nexport const MESSAGE_TYPES = {\r\n    BOOTSTRAP: \"bootstrap\",  // initialization message\r\n    BOOTSTRAPANSWER: \"bootstrap-answer\", // answer to the bootstrap message (to avoi conflict)\r\n    REQUESTID: \"request-id\", // get the id associated with the script\r\n    GET: \"get\",              // get an exposed property value\r\n    SET: \"set\",              // set an exposed property value\r\n    CALL: \"call\",            // call an exposed method\r\n    ANSWER: \"answer\",        // receive the answer after calling an exposed method\r\n    ERROR: \"error\"           // the exposed method call resulted in an error\r\n}\r\n\r\n/**\r\n * Class that will handle a connection to a script. It's not opinionated as to what this script is, if it's the background one or a content script.\r\n * \r\n * @property {chrome.runtime.Port} port The actual connection to the script.\r\n * @property {boolean} hasTabId Controls whether the connection has a port id or not. This will avoid errors in the $getMyId function within the Connection Proxy.\r\n * @property {Proxy} proxy The connection proxy that implements the RPC protocol.\r\n * @property {Map<number, function>} waitingRequests A map of all the requests that are waiting an answer. When an answer is received, the callback contained here will be fired.\r\n * @property {number} nextRequestId Integer that gets incremented every new request, in order to be used as a unique id.\r\n * @property {Array<string>} RESTRICTED_NAMES A list of function names that should not be called as RPC by the Proxy.\r\n * @property {Object.<string, function>} exposedMethods The methods exposed by the local script.\r\n * @property {Object.<string, any>} exposedProps The properties exposed by the local script.\r\n * @property {Array<string>} remoteMethods A list of the functions exposed by the connected script.\r\n */\r\nexport class Connection extends CustomEventTarget {\r\n    \r\n    /**\r\n     * Creates a new connection based on the port and other options.\r\n     * \r\n     * @param {chrome.runtime.Port} port The connection that we want to handle.\r\n     * @param {Object} exposedData The methods and properties we want to expose to the connected script.\r\n     * @param {Object} options\r\n     * @param {boolean} options.hasTabId Indicates whether or not the current script is associated to a tab.\r\n     */\r\n    constructor( port, exposedData = {}, options = {} ) {\r\n        super();\r\n\r\n        this.port = port;\r\n        this.hasTabId = options.hasTabId ?? true;\r\n\r\n        this.proxy = null;\r\n        this.waitingRequests = new Map();\r\n        this.nextRequestId = 1;\r\n        \r\n        this.RESTRICTED_NAMES = [\"then\", \"$getMyTabId\"];\r\n        this.exposedMethods = {};\r\n        this.exposedProps = {};\r\n        this.remoteMethods = [];\r\n\r\n\r\n        this.parseExposedData(exposedData);\r\n\r\n        this.port.onMessage.addListener( (message) => this.handleMessage(message) );\r\n\r\n        this.port.onDisconnect.addListener( () => {\r\n            this.fireEvent(\"disconnect\");\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Split the exposed datas into properties and methods, initializing the corresponding class properties.\r\n     * \r\n     * @param {Object} data \r\n     */\r\n    parseExposedData(data) {\r\n        // Split the exposed data between functions and properties, for easier access\r\n        for (let [key, value] of Object.entries(data)) {\r\n\r\n            if (this.RESTRICTED_NAMES.includes(key)) {\r\n                console.warn(`'${key}' is a restricted property name and will be ignored.`);\r\n                continue;\r\n            }\r\n\r\n            if (typeof value === \"function\") {\r\n                this.exposedMethods[key] = value;\r\n            }\r\n            else {\r\n                this.exposedProps[key] = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Start the connection initialization (send a bootstrap message to the connected script)\r\n     * \r\n     * @param {function} callback Function to be called when the initialization has been successful\r\n     */\r\n    initConnection(callback) {\r\n        let request = {\r\n            type: MESSAGE_TYPES.BOOTSTRAP,\r\n            exposedMethods: Object.keys(this.exposedMethods)\r\n        }\r\n\r\n        this._sendMessage(request, callback);\r\n    }\r\n\r\n    /**\r\n     * Return the proxy that will be used to make the RPCs.\r\n     */\r\n    getProxy() {\r\n        return new Promise( (resolve, reject) => {\r\n            // If the proxy is already initialized, return it\r\n            if (this.proxy) return resolve(this.proxy);\r\n\r\n            this.initConnection(resolve);\r\n        });\r\n    }\r\n\r\n    disconnect() {\r\n        this.port.disconnect();\r\n    }\r\n\r\n    /**\r\n     * Handle the incoming bootstrapping informations, and initializes the proxy.\r\n     * \r\n     * @param {Array<string>} remoteMethods The methods exposed by the connected script\r\n     */\r\n    receivedBootstrapInfo(remoteMethods) {\r\n        this.remoteMethods = remoteMethods;\r\n\r\n        this.initProxy();\r\n    }\r\n\r\n    /**\r\n     * Decide whether to send a response for the received message or not. It will also directly send the answer.\r\n     * \r\n     * @param {Object} message The incoming message\r\n     */\r\n    handleMessage(message) {\r\n        let response = this.handleMessageTypes(message);\r\n\r\n        // I need to check if response is not null, because a message of type \"call\" should not have an immediate answer\r\n        if (response) {\r\n            this.port.postMessage(response);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Decides how to answer based on the incomin message type.\r\n     * \r\n     * @param {Object} message The incoming message\r\n     */\r\n    handleMessageTypes(message) {\r\n        let callback;\r\n\r\n        switch (message.type) {\r\n            case MESSAGE_TYPES.BOOTSTRAP:\r\n\r\n                this.receivedBootstrapInfo(message.exposedMethods);\r\n            \r\n                return {\r\n                    type: MESSAGE_TYPES.BOOTSTRAPANSWER,\r\n                    id: message.id,\r\n                    exposedMethods: Object.keys(this.exposedMethods)\r\n                };\r\n            \r\n            case MESSAGE_TYPES.BOOTSTRAPANSWER:\r\n\r\n                this.receivedBootstrapInfo(message.exposedMethods);\r\n                callback = this.getRequestCallback(message.id);\r\n                callback(this.proxy);\r\n\r\n                return null;\r\n            \r\n            case MESSAGE_TYPES.REQUESTID:\r\n                return {\r\n                    type: MESSAGE_TYPES.ANSWER,\r\n                    id: message.id,\r\n                    result: this.port.sender?.tab?.id ?? null\r\n                }\r\n\r\n            case MESSAGE_TYPES.GET:\r\n                return {\r\n                    type: MESSAGE_TYPES.ANSWER,\r\n                    id: message.id,\r\n                    result: this.exposedProps[message.prop]\r\n                };\r\n\r\n            case MESSAGE_TYPES.SET:\r\n                let res = {\r\n                    type: MESSAGE_TYPES.ANSWER,\r\n                    id: message.id,\r\n                    result: undefined,\r\n                };\r\n\r\n                if (message.prop in this.exposedProps) {\r\n                    res.result = this.exposedProps[message.prop] = message.value;\r\n                }\r\n                \r\n                return res;\r\n            \r\n            case MESSAGE_TYPES.CALL:\r\n                if (!message.name in this.exposedMethods) {\r\n                    return {\r\n                        type: MESSAGE_TYPES.ANSWER,\r\n                        id: message.id,\r\n                        result: undefined\r\n                    };\r\n                }\r\n\r\n                this._promisify( this.exposedMethods[message.name], message.args )\r\n                    .then(\r\n                        (result) => this.sendCallResult(message.id, result)\r\n                    ).catch(\r\n                        (error) => {\r\n                            console.error(error); // Allows to see the problem within the throwing script too\r\n                            this.sendCallError(message.id, error);\r\n                        }\r\n                    );\r\n                \r\n                return null;\r\n            \r\n            case MESSAGE_TYPES.ANSWER:\r\n                callback = this.getRequestCallback(message.id);\r\n                callback(message.result);\r\n                return null;\r\n            \r\n            case MESSAGE_TYPES.ERROR:\r\n                throw message.error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sends back the result of a method that was called remotely.\r\n     * \r\n     * @param {number} id The message unique id\r\n     * @param {any} result The result of the executed method\r\n     */\r\n    sendCallResult(id, result) {\r\n        let message = {\r\n            type: MESSAGE_TYPES.ANSWER,\r\n            id,\r\n            result\r\n        };\r\n\r\n        return this.port.postMessage(message);\r\n    }\r\n\r\n    /**\r\n     * Sends back the error that was raised when a remotely called method fails.\r\n     * \r\n     * @param {number} id The message unique id\r\n     * @param {any} error The error raised during the method execution\r\n     */\r\n    sendCallError(id, error) {\r\n        let message = {\r\n            type: MESSAGE_TYPES.ERROR,\r\n            id,\r\n            error\r\n        };\r\n\r\n        return this.port.postMessage(message);\r\n    }\r\n\r\n    /**\r\n     * Init the connection proxy, setting the relevant traps.\r\n     * \r\n     * @return {Proxy}\r\n     */\r\n    initProxy() {\r\n        this.proxy = new Proxy({}, {\r\n            get: (target, property) => this.getTrap(target, property),\r\n            set: (target, property, value) => this.setTrap(target, property, value)\r\n        });\r\n\r\n        return this.proxy;\r\n    }\r\n\r\n    /**\r\n     * Handle what happens when the user access a property or executes a method on the proxy. It will send messages to the connected script.\r\n     * \r\n     * @param {Object} target Currently not used.\r\n     * @param {string} property The property that was requested (could also be a method name: proxy.foo() --> \"foo\").\r\n     */\r\n    getTrap(target, property) {\r\n\r\n        // Prevent access to a \"then\" property (could create problems)\r\n        if (property === \"then\") {\r\n            return undefined;\r\n        }\r\n\r\n        // Returns the tab id as seen by the local script.\r\n        if (property === \"$getMyTabId\") {\r\n            return () => {\r\n                return new Promise((resolve, reject) => {\r\n                    if (!this.hasTabId) return resolve(null);\r\n\r\n                    let request = {\r\n                        type: MESSAGE_TYPES.REQUESTID\r\n                    }\r\n\r\n                    this._sendMessage(request, resolve);\r\n                });\r\n            }\r\n        }\r\n\r\n        // Check if the requested property is a function\r\n        if (this._hasMethod(property)) {\r\n\r\n            // This is necessary to allow this syntax: `let result = await connection.remoteFunction()`\r\n            return (...args) => {\r\n\r\n                return new Promise((resolve, reject) => {\r\n                    \r\n                    let request = {\r\n                        type: MESSAGE_TYPES.CALL,\r\n                        name: property,\r\n                        args: args\r\n                    };\r\n\r\n                    this._sendMessage(request, resolve);\r\n                });\r\n            }\r\n\r\n        }\r\n\r\n        // Imply that it should get the property back\r\n        return new Promise((resolve, reject) => {\r\n\r\n            let request = {\r\n                type: MESSAGE_TYPES.GET,\r\n                prop: property\r\n            }\r\n\r\n            this._sendMessage(request, resolve);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handles what happens when a user set a variable on the connection proxy. This method will send a message to the connected script in order to set the remote property.\r\n     * \r\n     * @param {Object} target Currently not used.\r\n     * @param {string} property The proxy property to be set\r\n     * @param {any} value The new value of the property\r\n     */\r\n    setTrap(target, property, value) {\r\n        return new Promise((resolve, reject) => {\r\n            let request = {\r\n                type: MESSAGE_TYPES.SET,\r\n                prop: property,\r\n                value: value\r\n            }\r\n            \r\n            this._sendMessage(request, resolve);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Little helper function to return a message id and increment the \"nextRequestId\" property.\r\n     * \r\n     * @return {number} A new unique id for the message.\r\n     */\r\n    getNewRequestId() {\r\n        let id = this.nextRequestId;\r\n        this.nextRequestId++;\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * Get a callback for a specific request\r\n     * \r\n     * @param {number} id The request id (a.k.a. message id)\r\n     * @return {function} The callback\r\n     */\r\n    getRequestCallback(id) {\r\n        return this.waitingRequests.get(id);\r\n    }\r\n\r\n    /**\r\n     * Queue a callback that will be fired when the remote action is completed and an answer is received.\r\n     * \r\n     * @param {number} id The request id\r\n     * @param {function} callback The callback that will wait for the request to be completed\r\n     */\r\n    registerCallback(id, callback) {\r\n        this.waitingRequests.set(id, callback);\r\n    }\r\n    \r\n    /**\r\n     * Little helper function to check if the remote script has the requested method\r\n     * \r\n     * @param {string} methodName \r\n     */\r\n    _hasMethod(methodName) {\r\n        return ( this.remoteMethods.findIndex((n) => n === methodName) >= 0 );\r\n    }\r\n\r\n    /**\r\n     * Send a message to the connected script and enqueue a callback to wait for the answer.\r\n     * \r\n     * @param {Object} request \r\n     * @param {function} callback \r\n     */\r\n    _sendMessage(request, callback) {\r\n        let id = this.getNewRequestId();\r\n\r\n        request.id = id;\r\n\r\n        this.registerCallback(id, callback);\r\n        \r\n        this.port.postMessage(request);\r\n    }\r\n\r\n    /**\r\n     * Helper function to transform a synchronous method into asynchronous. It will leave asynchronous methods as-it-is.\r\n     * \r\n     * @param {function} func \r\n     * @param {Array<any>} args The function arguments\r\n     */\r\n    _promisify(func, args) {\r\n        let result = null;\r\n        try {\r\n            result = func(...args);\r\n        }\r\n        catch (err) {\r\n            // If the function threw an error (usually synchronous functions will throw here) then\r\n            // transform it into a rejected promise.\r\n            return new Promise((resolve, reject) => reject(err));\r\n        }\r\n        \r\n        // If it's a promise, then send it as it is\r\n        if (typeof(result) === \"object\" && \"then\" in result) {\r\n            return result;\r\n        }\r\n        // If it's not a promise, transform it into a resolved promise\r\n        return new Promise((resolve) => resolve(result));\r\n    }\r\n}\r\n\r\nexport default Connection;\r\n","export class Error {\r\n\r\n    /**\r\n     * Creates a new Error with a specific id and a function that will return useful informations\r\n     * \r\n     * @constructor\r\n     * @param {string} id A readable id for the error\r\n     * @param {function} getTextCallback A function that will return a description text for this error.\r\n     */\r\n    constructor( id, getTextCallback ) {\r\n        this.id = id;\r\n        this.getTextCallback = getTextCallback;\r\n    }\r\n\r\n    /**\r\n     * Get the error description text\r\n     * \r\n     * @param  {...any} args\r\n     * @returns {string} The description of this error \r\n     */\r\n    getText(...args) {\r\n        return this.getTextCallback(...args);\r\n    }\r\n}\r\n\r\nexport const BgHandlerErrors = {\r\n    ID_TAKEN: new Error('ID_TAKEN', (id) => `The id '${id}' has already been taken. It must be unique.` ),\r\n    NO_CONNECTION: new Error('NO_CONNECTION', (scriptId, tabId) => `There is no connection assigned to id '${scriptId}'${(tabId) ? ` connected to the tab ${tabId}` : ''}.`)\r\n};","import BgHandler from './src/BackgroundHandler.js';\r\nimport BgScript from './src/BackgroundScript.js';\r\n\r\nexport const BackgroundHandler = BgHandler;\r\nexport const BackgroundScript = BgScript;","import CustomEventTarget from './CustomEventTarget.js';\r\nimport { Connection, CONNECTION_PREFIX, CONNECTION_PREFIX_NOTAB } from './Connection.js';\r\n\r\n/** \r\n * Class that will handle the connection from a content script to the background script\r\n * \r\n * @property {string} scriptId A string that uniquely identifies this script file (could be in the context of a chrome tab or globally, depending on the context property).\r\n * @property {Object} exposedData An object containing all properties and methods to be exposed to the background script.\r\n * @property {Connection} connection The actual connection object that handles the communications with the background script.\r\n * @property {string} context The context of this script. \r\n */\r\nclass BackgroundScript extends CustomEventTarget {\r\n\r\n    /**\r\n     * It creates a new Background Script class and initialize all the class properties. It will also bootstrap the actual connection.\r\n     * \r\n     * @param {string} scriptId A unique ID to identify this script\r\n     * @param {Object} exposedData An object containing all properties and methods to be exposed to the background script\r\n     * @param {Object} options\r\n     * @param {string} options.context The context of this content script. It can have three values:\r\n     *                                     \"content\" - To be used in content scripts.\r\n     *                                     \"devtools\" - To be used in scripts that run from the devtools.\r\n     *                                     \"tab-agnostic\" - To be used in scripts that are not related to any tab, and are unique in your extension.\r\n     */\r\n    constructor(scriptId, exposedData = {}, options = { context: \"content\" }) {\r\n        super();\r\n\r\n        this.scriptId = scriptId ?? this._uuidv4();\r\n        this.connection = null;\r\n        this.exposedData = exposedData;\r\n        this.context = options.context ?? \"content\";\r\n\r\n        this.connectBackgroundScript();\r\n    }\r\n\r\n    /**\r\n     * Creates a connection to the background script based on the script context. It initializes the \"connection\" property.\r\n     */\r\n    connectBackgroundScript() {\r\n\r\n        let completeScriptId = \"\";\r\n\r\n        switch (this.context) {\r\n            case \"content\":\r\n                completeScriptId = CONNECTION_PREFIX + this.scriptId;\r\n                break;\r\n            case \"devtools\":\r\n                if (!chrome.devtools) throw \"Cannot set context='devtools' when the script is not in a devtools window.\";\r\n                completeScriptId = CONNECTION_PREFIX_NOTAB + this.scriptId + \"-\" + chrome.devtools.inspectedWindow.tabId;\r\n                break;\r\n            case \"tab-agnostic\":\r\n                completeScriptId = this.scriptId;\r\n                break;\r\n        }\r\n\r\n        let port = chrome.runtime.connect(\r\n            {\r\n                name: completeScriptId\r\n            }\r\n        );\r\n\r\n        this.connection = new Connection(port, this.exposedData);\r\n        \r\n        this.connection.addListener(\"disconnect\", () => {\r\n            this.disconnectBackgroundScript();\r\n        });\r\n\r\n        window.addEventListener(\"beforeunload\", () => {\r\n            this.disconnectBackgroundScript();\r\n        });\r\n\r\n        this.fireEvent(\"connected\", {});\r\n    }\r\n\r\n    /**\r\n     * Function to disconnect this script\r\n     */\r\n    disconnectBackgroundScript() {\r\n        if (this.connection) {\r\n            this.connection.disconnect();\r\n        }\r\n\r\n        this.connection = null;\r\n        this.fireEvent(\"disconnected\", {});\r\n    }\r\n\r\n    /**\r\n     * Function to retrieve the connection proxy.\r\n     * \r\n     * @async\r\n     * @return {Promise<Proxy>}\r\n     */\r\n    async getConnection() {\r\n\r\n        if (!this.connection) {\r\n            this.connectBackgroundScript();\r\n        }\r\n\r\n        let proxy = await this.connection.getProxy();\r\n        return proxy;\r\n    }\r\n\r\n    /**\r\n     * Function that returns a uuid version 4 formatted string.\r\n     * \r\n     * @return {string} the id.\r\n     */\r\n    _uuidv4() {\r\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\r\n            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\r\n            return v.toString(16);\r\n        });\r\n    }\r\n}\r\n\r\nexport default BackgroundScript;","import DOMTraversal from \"./utils/DOMTraversal\";\nimport StackingContext from './classes/StackingContext';\nimport { BackgroundScript } from '@andreadev/bg-script';\nimport { getNodeFromPath, getPathFromNode } from \"./utils/utils\";\n\nvar allContexts = null;\nvar rootContext = null;\nvar highlightDOM = initHighlightDOM();\nvar lastInspectedElement = null;\nvar observer = null;\nvar isObserverActive = false;\n\n\n/**\n * Analyse the page and initialize the 'allContexts' and 'rootContext' variables.\n */\nasync function analysePage() {\n    [rootContext, allContexts] = DOMTraversal.getContextsFromPage();\n}\n\n/**\n * Returns a copy of all the contexts converted to JSON.\n * \n * @return {Array} list of all contexts converted to JSON.\n */\nfunction getAllContextsJSON() {\n    let allContextsJSON = allContexts.map( context => context.toJSON() );\n    return allContextsJSON;\n}\n\n/**\n * Creates the element that will be used to highlight the contexts in the page.\n * \n * @return {Node} The actual DOM element with coherent styles applied.\n */\nfunction initHighlightDOM() {\n    let element = document.createElement(\"div\");\n    element.id = \"devtools-stacking-context-highlight\";\n    element.style.backgroundColor = \"rgba(0,200,255, 0.7)\";\n    element.style.position = \"fixed\";\n    element.style.zIndex = \"2147483647\";\n    element.style.display = \"none\";\n    return element;\n}\n\n/**\n * Highlight the DOM Element related to a context.\n * \n * @param {number} id The id of the context to be highlighted.\n */\nfunction highlightContext(id) {\n    let elementBCR = allContexts[id].element.getBoundingClientRect();\n    let relPos = getRelativePosition(allContexts[id]);\n    highlightDOM.style.top = (elementBCR.top + relPos.top) +  \"px\";\n    highlightDOM.style.left = (elementBCR.left + relPos.left) + \"px\";\n    highlightDOM.style.width = elementBCR.width + \"px\";\n    highlightDOM.style.height = elementBCR.height + \"px\";\n    highlightDOM.style.display = \"block\";\n    document.body.appendChild(highlightDOM);\n}\n\n/**\n * Get the relative position of a specific element in the page (iframes included)\n * \n * @param {StackingContext} context\n * @return {Object} The relative position of the context frame\n */\nfunction getRelativePosition(context) {\n    let relativePosition = { top: 0, left: 0 };\n    let current = context;\n\n    while (current) {\n        if (current.frame == null) break;\n\n        if (current.type === \"container\") {\n            let frameBCR = current.frame.getBoundingClientRect();\n            relativePosition.top += frameBCR.top;\n            relativePosition.left += frameBCR.left;\n        }\n        \n        current = current.parent;\n    }\n\n    return relativePosition;\n}\n\n/**\n * Remove the highlight element from the page.\n */\nfunction undoHighlightContext() {\n    highlightDOM.style.display = \"none\";\n    document.body.removeChild(highlightDOM);\n}\n\n/**\n * Scroll the page to show the element related to a specific context.\n * \n * @param {number} id The context id.\n */\nfunction scrollToContext(id) {\n    allContexts[id].element.scrollIntoView();\n}\n\n/**\n * Find the stacking context that contains a specific node as a child of its element. If the node creates a stacking context, return it.\n * \n * @param {Node} node The node of which we want to find the context.\n * @return {StackingContext} The context associated with the node or one of its parents.\n */\nfunction getContextIdFromNode(node) {\n\n    let lastParent = node;\n    while (lastParent !== null) {\n        \n        foundContext = allContexts.find( (context) => context.element === lastParent );\n        \n        if (foundContext) {\n            return foundContext;\n        }\n\n        // Check if I've reached a shadowroot container and work my way around it\n        if (lastParent.parentElement === null) {\n\n            let root = lastParent.getRootNode();\n            \n            if (root instanceof ShadowRoot) {\n                lastParent = root.host;\n                continue;\n            }\n        }\n\n        lastParent = lastParent.parentElement;\n    }\n\n    return null;\n}\n\n/**\n * Returns a path to get the element of a specific context even if it is inside an iframe or shadow DOM\n * \n * @param {Integer} contextId \n * @returns {Object[]}\n */\nfunction getPathFromContext(contextId) {\n    let context = allContexts.find( (context) => context.id == contextId );\n    return getPathFromNode( context.element );\n}\n\n/**\n * Detect which node was tagged as \"last inspected\" from the devtools, and initialize the related variable.\n */\nfunction detectLastInspectedElement(elementPath) {\n    \n    let element = null;\n\n    try {\n        element = getNodeFromPath(elementPath);\n    }\n    catch (e) {\n        element = null;\n    }\n    \n    if (!element) throw \"Cannot find element\";\n    \n    lastInspectedElement = element;\n}\n\n/**\n * Get some details about the last inspected element.\n * \n * @returns {Object} An object containing the id of the context associated to the element and whether or not the element creates a new stacking context.\n */\nfunction getInspectedElementDetails() {\n\n    let details = {\n        createsContext: false,\n        contextId: 0,\n        zIndex: \"auto\"\n    };\n\n    let passedChecks = DOMTraversal.getPassedChecks(lastInspectedElement);\n\n    if (passedChecks.length > 0) details.createsContext = true;\n\n    let context = getContextIdFromNode(lastInspectedElement);\n\n    details.contextId = context.id;\n\n    let styles = window.getComputedStyle(lastInspectedElement);\n\n    details.zIndex = styles.zIndex;\n\n    return details;\n}\n\n/**\n * Get all the iframes sources, to implement inspection on iframes\n * \n * @return {Array<string>} All the iframes src attributes\n */\nfunction getPageFramesSources() {\n    let iframes = Array.from( document.getElementsByTagName('iframe') );\n    let sources = iframes.map( (iframe) => iframe.src );\n    sources = sources.filter( (src) => src !== \"\" );\n    sources = [...new Set(sources)];\n    return sources;\n}\n\n/**\n * Attach a mutation observer to the DOM and notify the extension that the contexts should be refreshed\n */\nfunction setupDOMObserver() {\n    // This is used to debounce the \"DOM Changed\" notification\n    let lastCalled = new Date().getTime();\n\n    // Callback for the observer\n    const callback = (mutationsList, observer) => {\n        // Check if it has passed enough time from the last call\n        let now = new Date().getTime();\n        let debounceTime = 1000; // one second\n        \n        if (now - lastCalled < debounceTime) return;\n\n        // If we're not interested in these mutation, stop the function\n        if (!mutationsList.some(isImportantMutation)) return;\n\n        // If all the mutations are internal, stop the function\n        if (mutationsList.every(isInternalMutation)) return;\n\n        lastCalled = now;\n        sendDOMChangedWarning();\n    }\n\n    observer = new MutationObserver(callback);\n\n}\n\n/**\n * Just a utility function to allow adding and removing it as an event listener\n */\nfunction disconnectObserver() {\n    if (!isObserverActive) {\n        console.warn(\"Tried stopping the observer, but it was already stopped.\");\n        return;\n    }\n    observer.disconnect();\n    isObserverActive = false;\n}\n\n/**\n * Start observing the changes in the DOM\n */\nfunction startDOMObserver() {\n\n    if (isObserverActive) {\n        console.warn(\"Tried starting the observer, but it was already running.\");\n        return;\n    }\n\n    // Observer all the changes of the DOM elements position and attribute for the body tag and its children\n    const targetNode = document.body;\n    const config = { attributes: true, childList: true, subtree: true };\n    \n    observer.observe(targetNode, config);\n    isObserverActive = true;\n    \n    // Disconnect the observer when the user is leaving the page\n    window.addEventListener(\"beforeunload\", disconnectObserver);\n}\n\n\n/**\n * Stop observing the changes in the DOM\n */\nfunction stopDOMObserver() {\n    disconnectObserver();\n    window.removeEventListener(\"beforeunload\", disconnectObserver);\n} \n\n\n/**\n * Check whether or not we're interested in this mutation and want to send a warning in the extension panel and sidebar\n * \n * @param {MutationRecord} mutation \n * @returns {boolean}\n */\nfunction isImportantMutation(mutation) {\n    // If a DOM element has changed position or has been added / removed, it should notify\n    if (mutation.type === \"childList\") return true;\n\n    // If the \"style\", \"class\", \"id\" or \"data-xxx\" attributes change, it should notify (although any attribute might change the stacking contexts, this is just to make it lighter)\n    if (mutation.type === \"attributes\") {\n\n        let checkAttrs = [\"style\", \"class\", \"id\"];\n        if (checkAttrs.includes(mutation.attributeName)) return true;\n\n        if (mutation.attributeName.startsWith(\"data-\")) return true;\n    }\n    \n    return false;\n}\n\n/**\n * Check whether a specific mutation found by the observer was caused by our own extension or was generated by the page\n * \n * @param {MutationRecord} mutation \n * @returns {boolean}\n */\nfunction isInternalMutation(mutation) {\n    // Check if the target is our own overlay\n    if (mutation.target.id == \"devtools-stacking-context-highlight\") {\n        return true;\n    }\n    \n    // Check if the mutation was caused by our overlay\n    if (mutation.type == \"childList\") {\n        let element = null;\n\n        if (mutation.addedNodes.length == 1) element = mutation.addedNodes[0];\n        else if (mutation.removedNodes.length == 1) element = mutation.removedNodes[0];\n\n        if (element?.id == \"devtools-stacking-context-highlight\") {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Send a DOM Changed warning to the extension panel and sidebar \n */\nasync function sendDOMChangedWarning() {\n    let connection = await bgScript.getConnection();\n    \n    // Stop if a connection hasn't been found\n    if (connection == null) return;\n    \n    let tabId = await connection.$getMyTabId();\n\n    await connection.sendDOMChangedWarning(tabId);\n}\n\n\n// Setup the DOM Observer\nsetupDOMObserver();\n\n// Create the connection to the background script exposing the methods.\nlet scriptId = \"content\";\nif (window.top !== window.self) {\n    scriptId += \".\" + window.location.href;\n}\n\nvar bgScript = new BackgroundScript(scriptId, {\n    analysePage,\n    getAllContextsJSON,\n    highlightContext,\n    undoHighlightContext,\n    scrollToContext,\n    getPathFromContext,\n    detectLastInspectedElement,\n    getInspectedElementDetails,\n    getPageFramesSources,\n    startDOMObserver,\n    stopDOMObserver\n});","/**\r\n * Get a list of JSON-friendly stacking contexts that have only the context id set as the parent/children, and links them.\r\n * \r\n * @param {Array<Object>} contextsList A list of contexts with their  \r\n * @returns {Object} A representation of a stacking context adapted for the devtools scripts.\r\n */\r\nexport function generateContextTree(contextsList) {\r\n    let root = contextsList[0];\r\n\r\n    function linkChildren(context) {\r\n        // Get a context from its id (since the ids start from 0, the id is also its index inside the array)\r\n        context.children = context.children.map( (child) => contextsList[child] );\r\n        for (let child of context.children) {\r\n            child.parent = context;\r\n            linkChildren(child);\r\n        }\r\n    }\r\n\r\n    linkChildren(root);\r\n\r\n    return root;\r\n}\r\n\r\nexport function isValuableContainer(container) {\r\n    // Check if has children\r\n    if (container.children.length == 0) return false;\r\n    \r\n    // Check if some children is a stacking context\r\n    if (container.children.some((child) => child.type !== \"container\")) return true;\r\n\r\n    // Check the container children to see if they're valuable to show\r\n    if (container.children.some((child) => isValuableContainer(child))) return true;\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * This function returns an array of objects that represent the path that it takes to get from the main document to an element\r\n * regardless if it is inside an iframe, a shadow DOM or multiples of them. It walks up the documents until it reaches the main one.\r\n * If the element is inside a closed shadow root it will be unreachable, and \"null\" will be returned.\r\n * \r\n * !!! This function will be executed from its string representation, do not use other custom functions inside of it!\r\n * \r\n * @param {Node} node \r\n * @returns {Object[] | null}\r\n */\r\nexport function getPathFromNode(node) {\r\n    \r\n    let curElement = node;\r\n    let path = [];\r\n    let curRoot = null;\r\n\r\n    do {\r\n        // get root node of current element. Might be a shadow-root or an iframe document\r\n        curRoot = curElement.getRootNode();\r\n        \r\n\r\n        let pathFragment = {\r\n            index: Array.from(curRoot.querySelectorAll('*')).findIndex((el) => el === curElement),\r\n            type: \"document\"\r\n        }\r\n    \r\n        if (curRoot instanceof ShadowRoot) {\r\n            // element is inside a shadowRoot\r\n            pathFragment.type = \"shadow\";\r\n            \r\n            // if it's inside a closed shadow root, just return null, since it will be unreachable from the outside\r\n            if (curRoot.mode === \"closed\") {\r\n                return null;\r\n            }\r\n            \r\n            curElement = curRoot.host;\r\n        }\r\n        else if (curRoot !== document) {\r\n            // is inside an iframe\r\n            pathFragment.type = \"iframe\";\r\n\r\n            curElement = curRoot.defaultView.frameElement;\r\n        }\r\n    \r\n        path.push(pathFragment);\r\n\r\n    } while (curRoot !== document);\r\n\r\n    return path.reverse();\r\n}\r\n\r\n/**\r\n * Get a Node from the path generated by the getPathFromNode function\r\n * \r\n * @param {Object} path \r\n * @returns {Node}\r\n */\r\nexport function getNodeFromPath(path) {\r\n    \r\n    let curElement = null;\r\n\r\n    const elementFromIndex = (container, index) => container.querySelectorAll('*')[index];\r\n\r\n    for (let pathFragment of path) {\r\n        switch (pathFragment.type) {\r\n            case \"document\":\r\n                curElement = elementFromIndex(document, pathFragment.index);\r\n                break;\r\n            case \"shadow\":\r\n                curElement = elementFromIndex(curElement.shadowRoot, pathFragment.index);\r\n                break;\r\n            case \"iframe\":\r\n                curElement = elementFromIndex(curElement.contentDocument, pathFragment.index);\r\n                break;\r\n        }\r\n    }\r\n\r\n    return curElement;\r\n}"],"names":["$65764249770386fea041f92ad6e45b5a$var$asyncGeneratorStep","gen","resolve","reject","_next","_throw","key","arg","info","value","error","done","Promise","then","fn","self","this","args","arguments","apply","err","undefined","obj","Object","defineProperty","enumerable","configurable","writable","$8b528ea48efa75335a01ad74958243e0$export$3a0966c6f808b0dd","exec","element","elementStyle","window","getComputedStyle","callback","description","$8b528ea48efa75335a01ad74958243e0$export$52bac44ec52d81fa","styles","position","zIndex","opacity","parseFloat","isNaN","mixBlendMode","transform","filter","perspective","clipPath","mask","maskImage","maskBorder","some","prop","isolation","webkitOverflowScrolling","willChange","includes","contain","parentElement","display","$e5fa89e41a604cc38de7c11a2fff4f52$export$9099ad97b570f7c","addChild","context","children","push","toJSON","ref","ref1","ref2","ref3","ref4","ref5","ref6","parentId","parent","id","childrenIds","map","child","classes","classList","length","allElements","Array","from","document","getElementsByTagName","elementIndex","indexOf","elementStyles","ref25","ref26","elementDescription","tagName","toLowerCase","index","passedChecks","isInIframe","constructor","ref27","parentContext","ref28","frame","type","$4131cb4189155b1fb96a940f1206c443$var$allContexts","$4131cb4189155b1fb96a940f1206c443$var$traverse","$4131cb4189155b1fb96a940f1206c443$export$254c199d66650ac0","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","nodeType","Node","ELEMENT_NODE","return","contentDocument","documentElement","$4131cb4189155b1fb96a940f1206c443$var$isTraversableIframe","iframeDoc","container","$1508ed60f634f8b42ede1a8f449218c3$export$9099ad97b570f7c","body","shadowRoot","mode","$4131cb4189155b1fb96a940f1206c443$var$hasTraversableShadowDOM","_iteratorNormalCompletion1","_didIteratorError1","_iteratorError1","_step1","_iterator1","passed","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","check","$4131cb4189155b1fb96a940f1206c443$export$9099ad97b570f7c","rootContainer","$d790af4ba20ef5385a76e77ec09c5858$export$9099ad97b570f7c","listeners","Map","addListener","event","callbacksList","get","set","removeListener","callbackIndex","splice","fireEvent","details","$bba89e9ac323bbd46fff9f6a7aaeca59$export$8408ca23686660f6","$bba89e9ac323bbd46fff9f6a7aaeca59$export$257b00fb1c310327","$bba89e9ac323bbd46fff9f6a7aaeca59$export$8b350cd3497ac931","$bba89e9ac323bbd46fff9f6a7aaeca59$export$ee59c52cd68ef2e3","port","exposedData","proxy","nextRequestId","parseExposedData","onMessage","message","handleMessage","data","entries","RESTRICTED_NAMES","exposedMethods","exposedProps","keys","initConnection","remoteMethods","handleMessageTypes","postMessage","response","receivedBootstrapInfo","getRequestCallback","result","sender","tab","res","name","catch","console","initProxy","Proxy","target","property","getTrap","setTrap","request","_hasMethod","_sendMessage","$6c9ba9993c6605812e0c047d8233574b$export$85c64e8ae011fc6a","getTextCallback","$c7821ac8bf85ae093466d90ef52d7564$export$c3c55362089d3e17","scriptId","_uuidv4","options","connectBackgroundScript","completeScriptId","chrome","devtools","inspectedWindow","tabId","runtime","connect","disconnectBackgroundScript","$9215a956a71f73c376fb5a7b14614b2d$var$allContexts","$9215a956a71f73c376fb5a7b14614b2d$var$highlightDOM","createElement","style","backgroundColor","$9215a956a71f73c376fb5a7b14614b2d$var$initHighlightDOM","$9215a956a71f73c376fb5a7b14614b2d$var$lastInspectedElement","$9215a956a71f73c376fb5a7b14614b2d$var$observer","$9215a956a71f73c376fb5a7b14614b2d$var$isObserverActive","_analysePage","$65764249770386fea041f92ad6e45b5a$export$9099ad97b570f7c","getContextsFromPage","$9215a956a71f73c376fb5a7b14614b2d$var$disconnectObserver","disconnect","warn","$9215a956a71f73c376fb5a7b14614b2d$var$isImportantMutation","mutation","attributeName","startsWith","$9215a956a71f73c376fb5a7b14614b2d$var$isInternalMutation","addedNodes","removedNodes","_sendDOMChangedWarning","connection","$9215a956a71f73c376fb5a7b14614b2d$var$bgScript","getConnection","$getMyTabId","sendDOMChangedWarning","lastCalled","Date","getTime","MutationObserver","mutationsList","observer","now","every","$9215a956a71f73c376fb5a7b14614b2d$var$sendDOMChangedWarning","$9215a956a71f73c376fb5a7b14614b2d$var$setupDOMObserver","$9215a956a71f73c376fb5a7b14614b2d$var$scriptId","top","location","href","elementBCR","getBoundingClientRect","relPos","relativePosition","left","current","frameBCR","$9215a956a71f73c376fb5a7b14614b2d$var$getRelativePosition","width","height","appendChild","removeChild","scrollIntoView","contextId","node","curElement","path","curRoot","getRootNode","pathFragment","querySelectorAll","findIndex","el","ShadowRoot","host","defaultView","frameElement","reverse","$0136cbda44cc89b6a3366767f5f3578f$export$fc812c353c5b63ce","find","context1","elementPath","elementFromIndex","$0136cbda44cc89b6a3366767f5f3578f$export$2dc8b21eb8be3c43","e","createsContext","getPassedChecks","lastParent","foundContext","root","$9215a956a71f73c376fb5a7b14614b2d$var$getContextIdFromNode","sources","iframe","src","Set","targetNode","observe","attributes","childList","subtree","addEventListener","removeEventListener"],"version":3,"file":"content.js.map"}