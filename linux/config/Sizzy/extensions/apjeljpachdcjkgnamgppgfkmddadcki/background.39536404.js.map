{"mappings":"8jBAiBA,OAAAA,KAAAC,eAAAD,KAAAE,0HCbIC,EAAI,IAAOC,IAEXC,EAAgB,wBACO,8BACK,GAG5BC,EAAW,cAOgBC,4EAaR,CAACC,EAAAC,gBAGRC,QAAAC,MAAAC,IAAA,CACJ,sCAQI,MAAAC,GACRJ,EAAAI,+BADQC,kBAAA,UAAAC,OAAAC,QAAqBC,EAAA,QAAAF,GAAA,6BAYrCC,UAAAA,EAAAE,yBAAA,cAOkCC,EAAMD,yBAAA,QAEPE,MAAGpB,KAAAqB,sBA0CtBN,sCAGNO,KAAIC,cAASR,EAAA,CAEbS,KAAI,6BAXGhB,kCAoBAM,kBAAW,UAAAW,EAAAV,EAAAW,2BAAXC,EAAYC,mBAAKH,EAAAV,GAAA,oBAcjBc,EAAgBd,OACvBe,QAAUH,EAASI,oBAAoBN,EAAWV,QAChD,OAAWe,MAFUV,MAAApB,KAAAqB,oBAAhBJ,EAAiBQ,EAAOV,UAAxBiB,EAAgBZ,MAAApB,KAAAqB,oBAUhBY,WAAAA,uCAAAC,QAAAjB,EAA0B,UAAAF,gBAA1BmB,EAAAC,+CAYGf,MAAApB,KAASqB,oBADZe,iCAOE,UAAArB,EAAAsB,oCAFFH,EAAAI,iBAAkBD,OAAlBjB,MAAApB,KAAAqB,wBAsBA,WAXAP,kBAAgC,UAAEC,OAAlCmB,QAAAjB,EAA0B,UAAAF,sCAWAK,MANzCpB,KAAAqB,iCAaekB,EAAAzB,kBAAoB,UAAAC,EAAAsB,OAC3BH,QAAmBjB,EAAmB,UAAYF,SAClDmB,EAAOM,gBAAoBH,mDASJE,EAAAzB,kBAAA,UAAAC,EAAAsB,GAAhB,IAAAH,QALfjB,EAAA,UAIGF,gBAEKmB,EAAmBO,mBAAAJ,OAENjB,MAAApB,KAAgBqB,qDAWhB,UAAAN,EAAA2B,oCAHLR,EAAAS,2BAAeD,OAAftB,MAAApB,KAAAqB,wBA6BZ,8CApBWa,QAAAjB,EAA2B,UAAAF,gBAANmB,EAAAU,iCAoBGxB,MAACpB,KAAAqB,iCAQlBkB,EAAUzB,kBAAgB,UAAAC,OAEpCmB,QAAQjB,EAAA,UAAAF,gBACAmB,EAAAW,2BAGEzB,MAAApB,KAAAqB,mCAgBdP,kBAAA,UAAAC,8BAIR+B,QAAAC,IAAA,kCAIYb,EAAYc,iGAaCjC,eACrBE,EAAA,UAAwBF,wGAaxBkC,iCAEqB,UAAAlC,OACbC,QAAAC,EAA4B,QAAAF,GAAA,WACHE,EAAU,UAAAF,GAAA,GACnCC,UAAiBA,EAAAkC,iBAAA,IACjB/B,UAAyBA,EAAW+B,iBAAa,QAE7B9B,MAAApB,KAAaqB,sBAWEN,EAAAU,EAAA0B,WACnCJ,IAAA,eAAiBtB,0BAAAV,mBAAAoC,EAAA,SAAA,kBACThD,EAAyCS,IAAAG,GACjDqC,YACQ,IAAGC,IACSC,IAAAvC,EAAAwC,uCAK5B,IAAA,QACAA,EAAAtD,cAAAkD,QAMK,IAAK,UACFI,EAAArD,gBAAAiD,gBAIZ,kDA/DIpC,KACAK,MAAApB,KAAAqB,2BAgBJmC,EAAApC,MAEGpB,KAAAqB,8EAnJYY,EAAAb,MAAepB,KAAAqB,kDAgBfe,EAAAhB,MAAApB,KAA0BqB,0CAaCN,YAEjBK,MAAApB,KAAAqB,iDAGVoC,EAAArC,MAAApB,KAAAqB,wCAWgBN,EAAAsB,mFAoBhBqB,EAAqBtC,MAAApB,KAAAqB,gDAuBNN,UACtB4C,EAAgBvC,MAAApB,KAAAqB,4GAuEZN,4GAhPZ,SAGS6C,cACMC,SAAO,CAAErD,EAASC,KACzB,IAGQqD,OAAMpD,QAAAC,MAAA2C,IAAA,cAGN,qBAcD7C,EAAAI,mDAlCQO,MAAApB,KAAAqB","sources":["src/scripts/classes/TabStatus.js","src/scripts/background.js"],"sourcesContent":["/**\r\n * This class is used to represent the status of a tab. It contains informations on whether or not this\r\n * tab is currently inspected and which script they are connected to (panel, sidebar or both).\r\n * This class is manly used to check whether or not the DOM Observer should run.\r\n * \r\n * @property {boolean} isPanelActive Indicates whether the tab is being inspected with the Stacking Context Inspector panel or not\r\n * @property {boolean} isSidebarActive Indicates whether the tab is being inspected from the Stacking Context sidebar within the Elements panel or not\r\n */\r\nclass TabStatus {\r\n    isPanelActive = false;\r\n    isSidebarActive = false;\r\n\r\n    get isBeingInspected() {\r\n        return this.isPanelActive || this.isSidebarActive;\r\n    }\r\n}\r\n\r\nexport default TabStatus;","import { BackgroundHandler } from '@andreadev/bg-script';\r\nimport TabStatus from './classes/TabStatus';\r\n\r\n// Contain all the tabs status (see TabStatus class for more details)\r\nlet tabs = new Map();\r\n\r\nlet DEFAULT_SETTINGS = {\r\n    \"dom-changed-warning\": true,\r\n    \"contexts-click-to-expand\": false\r\n};\r\n\r\nlet settings = null;\r\n\r\n\r\n/**\r\n * Initialize the settings inside local storage to their default values\r\n */\r\nfunction initExtensionSettings() {\r\n    chrome.storage.local.set({ \"settings\": DEFAULT_SETTINGS });\r\n}\r\n\r\n/**\r\n * Load the extension settings\r\n * \r\n * @returns {Promise<Object>}\r\n */\r\nfunction loadExtensionSettings() {\r\n    return new Promise( (resolve, reject) => {\r\n        try {\r\n            chrome.storage.local.get([\"settings\"], (result) => {\r\n                settings = result.settings;\r\n                resolve(settings);\r\n            });\r\n        }\r\n        catch (e) {\r\n            reject(e);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Send a message to the extension panels to warn that the contexts should be refreshed.\r\n */\r\n async function notifySettingsChanged(tabId) {\r\n    let panelConnection = await getScriptConnection(\"panel\", tabId, false);\r\n    let sidebarConnection = await getScriptConnection(\"sidebar\", tabId, false);\r\n\r\n    if (panelConnection) {\r\n        await panelConnection.setShouldUpdateSettings(true);\r\n    }\r\n    if (sidebarConnection) {\r\n        await sidebarConnection.setShouldUpdateSettings(true);\r\n    }\r\n}\r\n\r\n/**\r\n * Save the new settings in the local chrome extension storage\r\n * \r\n * @param {Object} newSettings The updated settings\r\n * @returns {Promise}\r\n */\r\nfunction saveExtensionSettings(newSettings) {\r\n    return new Promise( (resolve, reject) => {\r\n        try {\r\n            chrome.storage.local.set({ settings: newSettings }, () => {\r\n\r\n                resolve();\r\n            });\r\n        }\r\n        catch (e) {\r\n            reject(e);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Inject the content script into a tab\r\n */\r\nfunction injectScript(tabId) {\r\n    return new Promise((resolve, reject) => {\r\n        chrome.tabs.executeScript(\r\n            tabId,\r\n            {\r\n                file: '/scripts/content.js'\r\n            },\r\n            () => {\r\n                resolve();\r\n            }\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * Get a script connection, and if there is no script associated with the tab, it injects it.\r\n * \r\n * @param {string} scriptId\r\n * @param {number} tabId \r\n * @param {boolean} analysePage Only when the scriptId is 'content', it forces a page analysis before returning the connection.\r\n * @returns {Promise<Connection>} The connection to the content script\r\n */\r\nasync function getScriptConnection(scriptId, tabId, injectOnFail=true) {\r\n\r\n    if (!bgHandler.hasConnectedScript(scriptId, tabId)) {\r\n        // Not returning anything if there is no script attached and we don't want to automatically inject the content script\r\n        if (!injectOnFail) return undefined;\r\n        \r\n        await injectScript(tabId);\r\n    }\r\n\r\n    let conn = await bgHandler.getScriptConnection(scriptId, tabId);\r\n\r\n    if (conn) return conn;\r\n}\r\n\r\n/**\r\n * Analyzes the page related to a specific tab id and returns a JSON description of the stacking contexts.\r\n * \r\n * @param {number} tabId \r\n * @returns {Array} The list of contexts in the page.\r\n */\r\nasync function analysePage(tabId) {\r\n    let connection = await getScriptConnection(\"content\", tabId);\r\n\r\n    await connection.analysePage();\r\n    let contexts = await connection.getAllContextsJSON();\r\n    return contexts;\r\n}\r\n\r\n/**\r\n * Highlight a context on a specific page.\r\n * \r\n * @param {number} tabId \r\n * @param {number} contextId The id of the context to be highlighted\r\n */\r\nasync function highlightContext(tabId, contextId) {\r\n    let connection = await getScriptConnection(\"content\", tabId);\r\n    await connection.highlightContext(contextId);\r\n}\r\n\r\n/**\r\n * Remove the highlight that was set on the context.\r\n * \r\n * @param {number} tabId \r\n */\r\nasync function undoHighlightContext(tabId) {\r\n    let connection = await getScriptConnection(\"content\", tabId);\r\n    await connection.undoHighlightContext();\r\n}\r\n\r\n/**\r\n * Scrolls the page related to a specific tab id in order to show a context.\r\n * \r\n * @param {number} tabId \r\n * @param {number} contextId \r\n */\r\nasync function scrollToContext(tabId, contextId) {\r\n    let connection = await getScriptConnection(\"content\", tabId);\r\n    await connection.scrollToContext(contextId);\r\n}\r\n\r\nasync function getPathFromContext(tabId, contextId) {\r\n    let connection = await getScriptConnection(\"content\", tabId);\r\n    return await connection.getPathFromContext(contextId);\r\n}\r\n\r\n/**\r\n * Instruct the content script related to a specific tab to get the details about the last inspected element.\r\n * \r\n * @param {number} tabId \r\n * @param {number} elementIndex The index of the last inspected element inside the DOM\r\n */\r\nasync function detectLastInspectedElement(tabId, elementIndex) {\r\n    let connection = await getScriptConnection(\"content\", tabId);\r\n    await connection.detectLastInspectedElement(elementIndex);\r\n} \r\n\r\n/**\r\n * Get some details about the last selected element and its context\r\n * \r\n * @param {number} tabId \r\n * @returns {Object} The element details\r\n */\r\nasync function getInspectedElementDetails(tabId) {\r\n    let connection = await getScriptConnection(\"content\", tabId);\r\n    let elementDetails = await connection.getInspectedElementDetails();\r\n\r\n    return elementDetails;\r\n} \r\n\r\nasync function getPageFramesSources(tabId) {\r\n    let connection = await getScriptConnection(\"content\", tabId);\r\n    let sources = await connection.getPageFramesSources();\r\n    return sources;\r\n}\r\n\r\n/**\r\n * Start the DOM Observer\r\n * \r\n * @param {number} tabId \r\n */\r\nasync function startDOMObserver(tabId) {\r\n    let connection = await getScriptConnection(\"content\", tabId);\r\n    console.log(\"Starting DOM Observer...\")\r\n    await connection.startDOMObserver();\r\n}\r\n\r\n/**\r\n * Stop the DOM Observer\r\n * \r\n * @param {number} tabId \r\n */\r\n async function stopDOMObserver(tabId) {\r\n    let connection = await getScriptConnection(\"content\", tabId);\r\n    console.log(\"Stopping DOM Observer...\")\r\n    await connection.stopDOMObserver();\r\n}\r\n\r\n/**\r\n * Send a message to the extension panels to warn that the contexts should be refreshed.\r\n */\r\nasync function sendDOMChangedWarning(tabId) {\r\n    let panelConnection = await getScriptConnection(\"panel\", tabId, false);\r\n    let sidebarConnection = await getScriptConnection(\"sidebar\", tabId, false);\r\n\r\n    if (panelConnection) {\r\n        await panelConnection.setShouldUpdate(true);\r\n    }\r\n    if (sidebarConnection) {\r\n        await sidebarConnection.setShouldUpdate(true);\r\n    }\r\n}\r\n\r\n/**\r\n * Update the devtools pages visibility status in order to decide whether to start or stop the DOM observer\r\n * \r\n * @param {number} tabId The tab id\r\n * @param {string} scriptId The script id\r\n * @param {boolean} visibilityStatus The current visibility status of the page where the specified script id is used\r\n */\r\nfunction updateDevtoolsPageStatus(tabId, scriptId, isActive) {\r\n    console.log(`The script '${scriptId}' related to the tab '${tabId}' is currently ${isActive ? 'active' : 'hidden'}`)\r\n\r\n    let tabStatus = tabs.get(tabId);\r\n    if (tabStatus == undefined) {\r\n        tabStatus = new TabStatus();\r\n        tabs.set(tabId, tabStatus);\r\n    }\r\n\r\n    let isInspected = tabStatus.isBeingInspected;\r\n\r\n    switch (scriptId) {\r\n        case \"panel\":\r\n            tabStatus.isPanelActive = isActive;\r\n            break\r\n        case \"sidebar\":\r\n            tabStatus.isSidebarActive = isActive;\r\n            break;\r\n        default:\r\n            return;\r\n    }\r\n\r\n    let isCurrentlyInspected = tabStatus.isBeingInspected;\r\n    \r\n    // If the overall page inspected status has changed, decide whether to start or stop the DOM Observer\r\n    if (isInspected == isCurrentlyInspected) return;\r\n\r\n    if (isCurrentlyInspected) {\r\n        startDOMObserver(tabId);\r\n    }\r\n    else {\r\n        stopDOMObserver(tabId);\r\n    }\r\n}\r\n\r\n/**\r\n * Handle the background handler errors (right now it just prints them to the console)\r\n */\r\nfunction onHandlerError(details) {\r\n    console.log(details.errorId);\r\n    console.error(details.error);\r\n}\r\n\r\nlet bgHandler = new BackgroundHandler({\r\n    analysePage,\r\n    highlightContext,\r\n    undoHighlightContext,\r\n    scrollToContext,\r\n    getPathFromContext,\r\n    detectLastInspectedElement,\r\n    getInspectedElementDetails,\r\n    getPageFramesSources,\r\n    sendDOMChangedWarning,\r\n    updateDevtoolsPageStatus,\r\n    loadExtensionSettings,\r\n    saveExtensionSettings,\r\n    notifySettingsChanged\r\n}, {\r\n    errorCallback: onHandlerError\r\n});\r\n\r\n/**\r\n * Initialization method\r\n */\r\nfunction init() {\r\n    // Add \"connection received\" handler to update tab status\r\n    bgHandler.addListener(\"connectionreceived\", ({scriptId, tabId}) => {\r\n        // Devtools script are tab-agnostic by default, so I'm appending the tab id to it using `scriptid-tabid` format\r\n        if (tabId == null) {\r\n            // Find the tab id delimiter\r\n            let delimiter = scriptId.search(\"-\");\r\n            // Get the tab id\r\n            tabId = parseInt(scriptId.substring(delimiter + 1));\r\n            // Get the clean script id\r\n            scriptId = scriptId.substring(0, delimiter);\r\n            // Notify the change\r\n            updateDevtoolsPageStatus(tabId, scriptId, true);\r\n        }\r\n    });\r\n\r\n    // Add \"connection ended\" handler to update tab status\r\n    bgHandler.addListener(\"connectionended\", ({scriptId, tabId}) => {\r\n        // Devtools script are tab-agnostic by default, so I'm appending the tab id to it using `scriptid-tabid` format\r\n        if (tabId == null) {\r\n            // Find the tab id delimiter\r\n            let delimiter = scriptId.search(\"-\");\r\n            // Get the tab id\r\n            tabId = parseInt(scriptId.substring(delimiter + 1));\r\n            // Get the clean script id\r\n            scriptId = scriptId.substring(0, delimiter);\r\n            // Notify the change\r\n            updateDevtoolsPageStatus(tabId, scriptId, false);\r\n        }\r\n    });\r\n\r\n    // Initialize Settings\r\n    loadExtensionSettings()\r\n        .then((settings) => {\r\n            if (!settings) {\r\n                initExtensionSettings();\r\n            }\r\n        })\r\n        .catch(() => {\r\n            initExtensionSettings();\r\n        });\r\n}\r\n\r\ninit();"],"names":["this","isPanelActive","isSidebarActive","$b79ea308cc3eec7e33943cd7fc2ee3db$var$tabs","Map","$b79ea308cc3eec7e33943cd7fc2ee3db$var$DEFAULT_SETTINGS","$b79ea308cc3eec7e33943cd7fc2ee3db$var$settings","$b79ea308cc3eec7e33943cd7fc2ee3db$var$initExtensionSettings","resolve","reject","storage","local","get","e","asyncToGenerator","tabId","panelConnection","$b79ea308cc3eec7e33943cd7fc2ee3db$var$getScriptConnection","setShouldUpdateSettings","sidebarConnection","apply","arguments","tabs","executeScript","file","scriptId","ref","$b79ea308cc3eec7e33943cd7fc2ee3db$var$bgHandler","hasConnectedScript","$b79ea308cc3eec7e33943cd7fc2ee3db$var$injectScript","conn","getScriptConnection","_getScriptConnection","_analysePage","connection","analysePage","_highlightContext","contextId","highlightContext","$2lHoE","scrollToContext","getPathFromContext","elementIndex","detectLastInspectedElement","getInspectedElementDetails","getPageFramesSources","console","log","startDOMObserver","_sendDOMChangedWarning","setShouldUpdate","isActive","undefined","$7fffc1ae5cb0801b50b09c0dac7fc2da$export$9099ad97b570f7c","set","tabStatus","_stopDOMObserver","_scrollToContext","_detectLastInspectedElement","_getInspectedElementDetails","newSettings","Promise","chrome"],"version":3,"file":"background.39536404.js.map"}