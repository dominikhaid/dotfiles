{"mappings":"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","sources":["node_modules/@swc/helpers/src/_async_to_generator.js","node_modules/@swc/helpers/src/_define_property.js","node_modules/@swc/helpers/src/_extends.js","node_modules/@swc/helpers/src/_object_spread.js","node_modules/@swc/helpers/src/_object_without_properties.js","node_modules/@swc/helpers/src/_object_without_properties_loose.js","node_modules/@swc/helpers/src/_sliced_to_array.js","node_modules/@swc/helpers/src/_array_with_holes.js","node_modules/@swc/helpers/src/_iterable_to_array.js","node_modules/@swc/helpers/src/_non_iterable_rest.js","node_modules/@andreadev/bg-script/index-modules.js","node_modules/@andreadev/bg-script/src/BackgroundHandler.js","node_modules/@andreadev/bg-script/src/CustomEventTarget.js","node_modules/@andreadev/bg-script/src/Connection.js","node_modules/@andreadev/bg-script/src/Errors.js","node_modules/@andreadev/bg-script/src/BackgroundScript.js"],"sourcesContent":["function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n","function extends_() {\n  extends_ = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return extends_.apply(this, arguments);\n}\n\nexport default function _extends() {\n  return extends_.apply(this, arguments);\n}\n","import defineProperty from './_define_property';\n\nexport default function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}","import objectWithoutPropertiesLoose from './_object_without_properties_loose';\n\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n","import arrayWithHoles from './_array_with_holes';\nimport iterableToArrayLimit from './_iterable_to_array';\nimport nonIterableRest from './_non_iterable_rest';\n\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n","export default function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n","import BgHandler from './src/BackgroundHandler.js';\r\nimport BgScript from './src/BackgroundScript.js';\r\n\r\nexport const BackgroundHandler = BgHandler;\r\nexport const BackgroundScript = BgScript;","import CustomEventTarget from './CustomEventTarget.js';\r\nimport { Connection, CONNECTION_PREFIX, CONNECTION_PREFIX_NOTAB } from './Connection.js';\r\nimport { BgHandlerErrors as ERRORS, Error } from './Errors';\r\n\r\n/** \r\n * Class that will handle all the content scripts that will connect to the background script.\r\n * \r\n * @property {Map<string, Connection>} scriptConnections A Map that will relate every script ID to its Connection object.\r\n * @property {object} exposedData The properties and methods exposed to the connecting scripts.\r\n * @property {function} errorCallback A callback that gets fired whenever there is an error in the script. It will get passed some details about the error.\r\n */\r\nclass BackgroundHandler extends CustomEventTarget {\r\n\r\n    /**\r\n     * Creates a new Background Handler and starts listening to new connections.\r\n     * \r\n     * @param {object} exposedData An object containing all properties and methods to be exposed to the content scripts\r\n     * @param {object} options Currently unused. An object that will customize how this class works.\r\n     */\r\n    constructor(exposedData = {}, options = {}) {\r\n        super();\r\n        \r\n        this.scriptConnections = new Map(); // script-id --> connection\r\n        this.exposedData = exposedData;\r\n        this.errorCallback = options.errorCallback ?? null;\r\n\r\n        chrome.runtime.onConnect.addListener( (port) => this.handleNewConnection(port) );\r\n    }\r\n\r\n    /**\r\n     * Handle a new incoming connection\r\n     * \r\n     * @param {chrome.runtime.Port} port The newly created connection to a content script\r\n     */\r\n    handleNewConnection(port) {\r\n\r\n        if (!this.isInternalConnection(port)) return;\r\n\r\n        let [name, scriptId] = this.parsePortName(port);\r\n        let tabId = port.sender?.tab?.id ?? null;\r\n        if (tabId == -1) tabId = null;\r\n\r\n        // If the script id is already taken, terminate the connection and send an error\r\n        if (this.scriptConnections.get(scriptId)) {\r\n            port.disconnect();\r\n            return this.handleError(ERRORS.ID_TAKEN, scriptId);\r\n        }\r\n\r\n        // In the background script, there is no tab-id associated\r\n        let connectionOptions = { hasTabId: false };\r\n\r\n        let connection = new Connection(port, this.exposedData, connectionOptions);\r\n\r\n        connection.addListener(\"disconnect\", () => this.disconnectScript(name, tabId) );\r\n\r\n        this.scriptConnections.set(scriptId, connection);\r\n\r\n        // Fire the connection event\r\n        this.fireEvent(\"connectionreceived\", {\r\n            scriptId: name,\r\n            tabId\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Checks if the connection was initialized from this library\r\n     * \r\n     * @param {chrome.runtime.Port} port The connection \r\n     */\r\n    isInternalConnection(port) {\r\n        return port.name.startsWith(CONNECTION_PREFIX) ||\r\n               port.name.startsWith(CONNECTION_PREFIX_NOTAB);\r\n    }\r\n\r\n    /**\r\n     * Check if the connection should not be related to any chrome tab\r\n     * \r\n     * @param {chrome.runtime.Port} port The connection\r\n     */\r\n    isTabAgnostic(port) {\r\n        return port.name.startsWith(CONNECTION_PREFIX_NOTAB);\r\n    }\r\n\r\n    /**\r\n     * Parse the port name and extracts a unique identifier (the script id).\r\n     * \r\n     * @param {chrome.runtime.Port} port The connection\r\n     * @returns {string} The script id\r\n     */\r\n    parsePortName(port) {\r\n        let scriptId, tabId, completeScriptId;\r\n\r\n        if (this.isTabAgnostic(port)) {\r\n            scriptId = port.name.substr(CONNECTION_PREFIX_NOTAB.length);\r\n        }\r\n        else {\r\n            scriptId = port.name.substr(CONNECTION_PREFIX.length);\r\n            tabId = port.sender.tab.id;\r\n        }\r\n\r\n        completeScriptId = this.generateScriptId(scriptId, tabId);\r\n\r\n        return [scriptId, completeScriptId];\r\n    }\r\n\r\n    /**\r\n     * Generate a script id to be used within the connections map\r\n     * \r\n     * @param {string} name \r\n     * @param {number} tabId \r\n     * @returns {string} The generated script id\r\n     */\r\n    generateScriptId(name, tabId) {\r\n        let scriptId = name;\r\n        if (tabId) {\r\n            scriptId += `-${tabId}`;\r\n        }\r\n        return scriptId;\r\n    }\r\n\r\n    /**\r\n     * Disconnect a script based on its id \r\n     * \r\n     * @param {string} id\r\n     */\r\n    disconnectScript(name, tabId) {\r\n        let id = this.generateScriptId(name, tabId);\r\n        let conn = this.scriptConnections.get(id);\r\n\r\n        // Disconnect the script if it hasn't disconnected yet\r\n        if (conn) {\r\n            conn.disconnect();\r\n        }\r\n        \r\n        // Remove the script in the connections map\r\n        this.scriptConnections.delete(id);\r\n        // Fire the disconnection event\r\n        this.fireEvent(\"connectionended\", {\r\n            scriptId: name,\r\n            tabId\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the connection to a script based on its id and the chrome tab that it's associated with.\r\n     * \r\n     * @async\r\n     * @param {string} scriptId The id of the script to which you want to get a connection\r\n     * @param {string} tabId The id of the chrome tab this scripts relates to\r\n     * @return {Promise<Proxy>} The connection proxy\r\n     */\r\n    async getScriptConnection(scriptId, tabId) {\r\n\r\n        let specificScriptId = scriptId;\r\n\r\n        if (tabId) specificScriptId += `-${tabId}`;\r\n\r\n        let connection = this.scriptConnections.get(specificScriptId);\r\n\r\n        if (!connection) {\r\n            this.handleError(ERRORS.NO_CONNECTION, scriptId, tabId);\r\n            return null;\r\n        }\r\n\r\n        let proxy = await connection.getProxy();\r\n\r\n        return proxy;\r\n    }\r\n\r\n    /**\r\n     * Check if a script with a specific id associated to a specific tab has made a connection to the background page.\r\n     * \r\n     * @param {string} scriptId \r\n     * @param {string} tabId \r\n     * @returns Whether the script is connected\r\n     */\r\n    hasConnectedScript(scriptId, tabId) {\r\n        let specificScriptId = scriptId;\r\n\r\n        if (tabId) specificScriptId += `-${tabId}`;\r\n\r\n        return this.scriptConnections.has(specificScriptId);\r\n    }\r\n\r\n    /**\r\n     * Handle the errors thrown within the class\r\n     * \r\n     * @param {Error} error \r\n     * @param  {...any} args \r\n     * @returns \r\n     */\r\n    handleError(error, ...args) {\r\n        if (this.errorCallback) {\r\n            this.errorCallback({\r\n                errorId: error.id,\r\n                error: error.getText(...args)\r\n            });\r\n\r\n            return;\r\n        }\r\n\r\n        console.error(error.getText(...args));\r\n    }\r\n}\r\n\r\nexport default BackgroundHandler;","class CustomEventTarget {\r\n    \r\n    constructor () {\r\n        this.listeners = new Map(); // event --> listeners\r\n    }\r\n\r\n    addListener(event, callback) {\r\n        if (typeof(callback) !== \"function\") throw \"The callback must be a function\";\r\n\r\n        let callbacksList = this.listeners.get(event);\r\n\r\n        if (!callbacksList) {\r\n            this.listeners.set(event, [callback]);\r\n            return;\r\n        }\r\n\r\n        callbacksList.push(callback);\r\n    }\r\n\r\n    removeListener(event, callback) {\r\n        let callbacksList = this.listeners.get(event);\r\n\r\n        if (!callbacksList) return;\r\n\r\n        let callbackIndex = callbacksList.indexOf(callback);\r\n\r\n        if (callbackIndex < 0) return;\r\n\r\n        callbacksList.splice(callbackIndex, 1);\r\n    }\r\n\r\n    fireEvent(event, details = {}) {\r\n        let callbacksList = this.listeners.get(event);\r\n\r\n        if (!callbacksList) return;\r\n\r\n        for (let callback of callbacksList) {\r\n            callback(details);\r\n        }\r\n    }\r\n}\r\n\r\nexport default CustomEventTarget;","import CustomEventTarget from './CustomEventTarget.js';\r\n\r\n/** @constant {string} CONNECTION_PREFIX A prefix added to the connection port name to recognize a connection from within the bgscript library. */\r\nexport const CONNECTION_PREFIX = \"bgscript-\";\r\n\r\n/** @constant {string} CONNECTION_PREFIX_NOTAB A prefix added to the connection port name to recognize an internal connection to a script that is not associated with any chrome tab. */\r\nexport const CONNECTION_PREFIX_NOTAB = \"bgscript.notab-\";\r\n\r\n/** @constant {object} MESSAGE_TYPES It contains all the message types values to be used in the code */\r\nexport const MESSAGE_TYPES = {\r\n    BOOTSTRAP: \"bootstrap\",  // initialization message\r\n    BOOTSTRAPANSWER: \"bootstrap-answer\", // answer to the bootstrap message (to avoi conflict)\r\n    REQUESTID: \"request-id\", // get the id associated with the script\r\n    GET: \"get\",              // get an exposed property value\r\n    SET: \"set\",              // set an exposed property value\r\n    CALL: \"call\",            // call an exposed method\r\n    ANSWER: \"answer\",        // receive the answer after calling an exposed method\r\n    ERROR: \"error\"           // the exposed method call resulted in an error\r\n}\r\n\r\n/**\r\n * Class that will handle a connection to a script. It's not opinionated as to what this script is, if it's the background one or a content script.\r\n * \r\n * @property {chrome.runtime.Port} port The actual connection to the script.\r\n * @property {boolean} hasTabId Controls whether the connection has a port id or not. This will avoid errors in the $getMyId function within the Connection Proxy.\r\n * @property {Proxy} proxy The connection proxy that implements the RPC protocol.\r\n * @property {Map<number, function>} waitingRequests A map of all the requests that are waiting an answer. When an answer is received, the callback contained here will be fired.\r\n * @property {number} nextRequestId Integer that gets incremented every new request, in order to be used as a unique id.\r\n * @property {Array<string>} RESTRICTED_NAMES A list of function names that should not be called as RPC by the Proxy.\r\n * @property {Object.<string, function>} exposedMethods The methods exposed by the local script.\r\n * @property {Object.<string, any>} exposedProps The properties exposed by the local script.\r\n * @property {Array<string>} remoteMethods A list of the functions exposed by the connected script.\r\n */\r\nexport class Connection extends CustomEventTarget {\r\n    \r\n    /**\r\n     * Creates a new connection based on the port and other options.\r\n     * \r\n     * @param {chrome.runtime.Port} port The connection that we want to handle.\r\n     * @param {Object} exposedData The methods and properties we want to expose to the connected script.\r\n     * @param {Object} options\r\n     * @param {boolean} options.hasTabId Indicates whether or not the current script is associated to a tab.\r\n     */\r\n    constructor( port, exposedData = {}, options = {} ) {\r\n        super();\r\n\r\n        this.port = port;\r\n        this.hasTabId = options.hasTabId ?? true;\r\n\r\n        this.proxy = null;\r\n        this.waitingRequests = new Map();\r\n        this.nextRequestId = 1;\r\n        \r\n        this.RESTRICTED_NAMES = [\"then\", \"$getMyTabId\"];\r\n        this.exposedMethods = {};\r\n        this.exposedProps = {};\r\n        this.remoteMethods = [];\r\n\r\n\r\n        this.parseExposedData(exposedData);\r\n\r\n        this.port.onMessage.addListener( (message) => this.handleMessage(message) );\r\n\r\n        this.port.onDisconnect.addListener( () => {\r\n            this.fireEvent(\"disconnect\");\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Split the exposed datas into properties and methods, initializing the corresponding class properties.\r\n     * \r\n     * @param {Object} data \r\n     */\r\n    parseExposedData(data) {\r\n        // Split the exposed data between functions and properties, for easier access\r\n        for (let [key, value] of Object.entries(data)) {\r\n\r\n            if (this.RESTRICTED_NAMES.includes(key)) {\r\n                console.warn(`'${key}' is a restricted property name and will be ignored.`);\r\n                continue;\r\n            }\r\n\r\n            if (typeof value === \"function\") {\r\n                this.exposedMethods[key] = value;\r\n            }\r\n            else {\r\n                this.exposedProps[key] = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Start the connection initialization (send a bootstrap message to the connected script)\r\n     * \r\n     * @param {function} callback Function to be called when the initialization has been successful\r\n     */\r\n    initConnection(callback) {\r\n        let request = {\r\n            type: MESSAGE_TYPES.BOOTSTRAP,\r\n            exposedMethods: Object.keys(this.exposedMethods)\r\n        }\r\n\r\n        this._sendMessage(request, callback);\r\n    }\r\n\r\n    /**\r\n     * Return the proxy that will be used to make the RPCs.\r\n     */\r\n    getProxy() {\r\n        return new Promise( (resolve, reject) => {\r\n            // If the proxy is already initialized, return it\r\n            if (this.proxy) return resolve(this.proxy);\r\n\r\n            this.initConnection(resolve);\r\n        });\r\n    }\r\n\r\n    disconnect() {\r\n        this.port.disconnect();\r\n    }\r\n\r\n    /**\r\n     * Handle the incoming bootstrapping informations, and initializes the proxy.\r\n     * \r\n     * @param {Array<string>} remoteMethods The methods exposed by the connected script\r\n     */\r\n    receivedBootstrapInfo(remoteMethods) {\r\n        this.remoteMethods = remoteMethods;\r\n\r\n        this.initProxy();\r\n    }\r\n\r\n    /**\r\n     * Decide whether to send a response for the received message or not. It will also directly send the answer.\r\n     * \r\n     * @param {Object} message The incoming message\r\n     */\r\n    handleMessage(message) {\r\n        let response = this.handleMessageTypes(message);\r\n\r\n        // I need to check if response is not null, because a message of type \"call\" should not have an immediate answer\r\n        if (response) {\r\n            this.port.postMessage(response);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Decides how to answer based on the incomin message type.\r\n     * \r\n     * @param {Object} message The incoming message\r\n     */\r\n    handleMessageTypes(message) {\r\n        let callback;\r\n\r\n        switch (message.type) {\r\n            case MESSAGE_TYPES.BOOTSTRAP:\r\n\r\n                this.receivedBootstrapInfo(message.exposedMethods);\r\n            \r\n                return {\r\n                    type: MESSAGE_TYPES.BOOTSTRAPANSWER,\r\n                    id: message.id,\r\n                    exposedMethods: Object.keys(this.exposedMethods)\r\n                };\r\n            \r\n            case MESSAGE_TYPES.BOOTSTRAPANSWER:\r\n\r\n                this.receivedBootstrapInfo(message.exposedMethods);\r\n                callback = this.getRequestCallback(message.id);\r\n                callback(this.proxy);\r\n\r\n                return null;\r\n            \r\n            case MESSAGE_TYPES.REQUESTID:\r\n                return {\r\n                    type: MESSAGE_TYPES.ANSWER,\r\n                    id: message.id,\r\n                    result: this.port.sender?.tab?.id ?? null\r\n                }\r\n\r\n            case MESSAGE_TYPES.GET:\r\n                return {\r\n                    type: MESSAGE_TYPES.ANSWER,\r\n                    id: message.id,\r\n                    result: this.exposedProps[message.prop]\r\n                };\r\n\r\n            case MESSAGE_TYPES.SET:\r\n                let res = {\r\n                    type: MESSAGE_TYPES.ANSWER,\r\n                    id: message.id,\r\n                    result: undefined,\r\n                };\r\n\r\n                if (message.prop in this.exposedProps) {\r\n                    res.result = this.exposedProps[message.prop] = message.value;\r\n                }\r\n                \r\n                return res;\r\n            \r\n            case MESSAGE_TYPES.CALL:\r\n                if (!message.name in this.exposedMethods) {\r\n                    return {\r\n                        type: MESSAGE_TYPES.ANSWER,\r\n                        id: message.id,\r\n                        result: undefined\r\n                    };\r\n                }\r\n\r\n                this._promisify( this.exposedMethods[message.name], message.args )\r\n                    .then(\r\n                        (result) => this.sendCallResult(message.id, result)\r\n                    ).catch(\r\n                        (error) => {\r\n                            console.error(error); // Allows to see the problem within the throwing script too\r\n                            this.sendCallError(message.id, error);\r\n                        }\r\n                    );\r\n                \r\n                return null;\r\n            \r\n            case MESSAGE_TYPES.ANSWER:\r\n                callback = this.getRequestCallback(message.id);\r\n                callback(message.result);\r\n                return null;\r\n            \r\n            case MESSAGE_TYPES.ERROR:\r\n                throw message.error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sends back the result of a method that was called remotely.\r\n     * \r\n     * @param {number} id The message unique id\r\n     * @param {any} result The result of the executed method\r\n     */\r\n    sendCallResult(id, result) {\r\n        let message = {\r\n            type: MESSAGE_TYPES.ANSWER,\r\n            id,\r\n            result\r\n        };\r\n\r\n        return this.port.postMessage(message);\r\n    }\r\n\r\n    /**\r\n     * Sends back the error that was raised when a remotely called method fails.\r\n     * \r\n     * @param {number} id The message unique id\r\n     * @param {any} error The error raised during the method execution\r\n     */\r\n    sendCallError(id, error) {\r\n        let message = {\r\n            type: MESSAGE_TYPES.ERROR,\r\n            id,\r\n            error\r\n        };\r\n\r\n        return this.port.postMessage(message);\r\n    }\r\n\r\n    /**\r\n     * Init the connection proxy, setting the relevant traps.\r\n     * \r\n     * @return {Proxy}\r\n     */\r\n    initProxy() {\r\n        this.proxy = new Proxy({}, {\r\n            get: (target, property) => this.getTrap(target, property),\r\n            set: (target, property, value) => this.setTrap(target, property, value)\r\n        });\r\n\r\n        return this.proxy;\r\n    }\r\n\r\n    /**\r\n     * Handle what happens when the user access a property or executes a method on the proxy. It will send messages to the connected script.\r\n     * \r\n     * @param {Object} target Currently not used.\r\n     * @param {string} property The property that was requested (could also be a method name: proxy.foo() --> \"foo\").\r\n     */\r\n    getTrap(target, property) {\r\n\r\n        // Prevent access to a \"then\" property (could create problems)\r\n        if (property === \"then\") {\r\n            return undefined;\r\n        }\r\n\r\n        // Returns the tab id as seen by the local script.\r\n        if (property === \"$getMyTabId\") {\r\n            return () => {\r\n                return new Promise((resolve, reject) => {\r\n                    if (!this.hasTabId) return resolve(null);\r\n\r\n                    let request = {\r\n                        type: MESSAGE_TYPES.REQUESTID\r\n                    }\r\n\r\n                    this._sendMessage(request, resolve);\r\n                });\r\n            }\r\n        }\r\n\r\n        // Check if the requested property is a function\r\n        if (this._hasMethod(property)) {\r\n\r\n            // This is necessary to allow this syntax: `let result = await connection.remoteFunction()`\r\n            return (...args) => {\r\n\r\n                return new Promise((resolve, reject) => {\r\n                    \r\n                    let request = {\r\n                        type: MESSAGE_TYPES.CALL,\r\n                        name: property,\r\n                        args: args\r\n                    };\r\n\r\n                    this._sendMessage(request, resolve);\r\n                });\r\n            }\r\n\r\n        }\r\n\r\n        // Imply that it should get the property back\r\n        return new Promise((resolve, reject) => {\r\n\r\n            let request = {\r\n                type: MESSAGE_TYPES.GET,\r\n                prop: property\r\n            }\r\n\r\n            this._sendMessage(request, resolve);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handles what happens when a user set a variable on the connection proxy. This method will send a message to the connected script in order to set the remote property.\r\n     * \r\n     * @param {Object} target Currently not used.\r\n     * @param {string} property The proxy property to be set\r\n     * @param {any} value The new value of the property\r\n     */\r\n    setTrap(target, property, value) {\r\n        return new Promise((resolve, reject) => {\r\n            let request = {\r\n                type: MESSAGE_TYPES.SET,\r\n                prop: property,\r\n                value: value\r\n            }\r\n            \r\n            this._sendMessage(request, resolve);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Little helper function to return a message id and increment the \"nextRequestId\" property.\r\n     * \r\n     * @return {number} A new unique id for the message.\r\n     */\r\n    getNewRequestId() {\r\n        let id = this.nextRequestId;\r\n        this.nextRequestId++;\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * Get a callback for a specific request\r\n     * \r\n     * @param {number} id The request id (a.k.a. message id)\r\n     * @return {function} The callback\r\n     */\r\n    getRequestCallback(id) {\r\n        return this.waitingRequests.get(id);\r\n    }\r\n\r\n    /**\r\n     * Queue a callback that will be fired when the remote action is completed and an answer is received.\r\n     * \r\n     * @param {number} id The request id\r\n     * @param {function} callback The callback that will wait for the request to be completed\r\n     */\r\n    registerCallback(id, callback) {\r\n        this.waitingRequests.set(id, callback);\r\n    }\r\n    \r\n    /**\r\n     * Little helper function to check if the remote script has the requested method\r\n     * \r\n     * @param {string} methodName \r\n     */\r\n    _hasMethod(methodName) {\r\n        return ( this.remoteMethods.findIndex((n) => n === methodName) >= 0 );\r\n    }\r\n\r\n    /**\r\n     * Send a message to the connected script and enqueue a callback to wait for the answer.\r\n     * \r\n     * @param {Object} request \r\n     * @param {function} callback \r\n     */\r\n    _sendMessage(request, callback) {\r\n        let id = this.getNewRequestId();\r\n\r\n        request.id = id;\r\n\r\n        this.registerCallback(id, callback);\r\n        \r\n        this.port.postMessage(request);\r\n    }\r\n\r\n    /**\r\n     * Helper function to transform a synchronous method into asynchronous. It will leave asynchronous methods as-it-is.\r\n     * \r\n     * @param {function} func \r\n     * @param {Array<any>} args The function arguments\r\n     */\r\n    _promisify(func, args) {\r\n        let result = null;\r\n        try {\r\n            result = func(...args);\r\n        }\r\n        catch (err) {\r\n            // If the function threw an error (usually synchronous functions will throw here) then\r\n            // transform it into a rejected promise.\r\n            return new Promise((resolve, reject) => reject(err));\r\n        }\r\n        \r\n        // If it's a promise, then send it as it is\r\n        if (typeof(result) === \"object\" && \"then\" in result) {\r\n            return result;\r\n        }\r\n        // If it's not a promise, transform it into a resolved promise\r\n        return new Promise((resolve) => resolve(result));\r\n    }\r\n}\r\n\r\nexport default Connection;\r\n","export class Error {\r\n\r\n    /**\r\n     * Creates a new Error with a specific id and a function that will return useful informations\r\n     * \r\n     * @constructor\r\n     * @param {string} id A readable id for the error\r\n     * @param {function} getTextCallback A function that will return a description text for this error.\r\n     */\r\n    constructor( id, getTextCallback ) {\r\n        this.id = id;\r\n        this.getTextCallback = getTextCallback;\r\n    }\r\n\r\n    /**\r\n     * Get the error description text\r\n     * \r\n     * @param  {...any} args\r\n     * @returns {string} The description of this error \r\n     */\r\n    getText(...args) {\r\n        return this.getTextCallback(...args);\r\n    }\r\n}\r\n\r\nexport const BgHandlerErrors = {\r\n    ID_TAKEN: new Error('ID_TAKEN', (id) => `The id '${id}' has already been taken. It must be unique.` ),\r\n    NO_CONNECTION: new Error('NO_CONNECTION', (scriptId, tabId) => `There is no connection assigned to id '${scriptId}'${(tabId) ? ` connected to the tab ${tabId}` : ''}.`)\r\n};","import CustomEventTarget from './CustomEventTarget.js';\r\nimport { Connection, CONNECTION_PREFIX, CONNECTION_PREFIX_NOTAB } from './Connection.js';\r\n\r\n/** \r\n * Class that will handle the connection from a content script to the background script\r\n * \r\n * @property {string} scriptId A string that uniquely identifies this script file (could be in the context of a chrome tab or globally, depending on the context property).\r\n * @property {Object} exposedData An object containing all properties and methods to be exposed to the background script.\r\n * @property {Connection} connection The actual connection object that handles the communications with the background script.\r\n * @property {string} context The context of this script. \r\n */\r\nclass BackgroundScript extends CustomEventTarget {\r\n\r\n    /**\r\n     * It creates a new Background Script class and initialize all the class properties. It will also bootstrap the actual connection.\r\n     * \r\n     * @param {string} scriptId A unique ID to identify this script\r\n     * @param {Object} exposedData An object containing all properties and methods to be exposed to the background script\r\n     * @param {Object} options\r\n     * @param {string} options.context The context of this content script. It can have three values:\r\n     *                                     \"content\" - To be used in content scripts.\r\n     *                                     \"devtools\" - To be used in scripts that run from the devtools.\r\n     *                                     \"tab-agnostic\" - To be used in scripts that are not related to any tab, and are unique in your extension.\r\n     */\r\n    constructor(scriptId, exposedData = {}, options = { context: \"content\" }) {\r\n        super();\r\n\r\n        this.scriptId = scriptId ?? this._uuidv4();\r\n        this.connection = null;\r\n        this.exposedData = exposedData;\r\n        this.context = options.context ?? \"content\";\r\n\r\n        this.connectBackgroundScript();\r\n    }\r\n\r\n    /**\r\n     * Creates a connection to the background script based on the script context. It initializes the \"connection\" property.\r\n     */\r\n    connectBackgroundScript() {\r\n\r\n        let completeScriptId = \"\";\r\n\r\n        switch (this.context) {\r\n            case \"content\":\r\n                completeScriptId = CONNECTION_PREFIX + this.scriptId;\r\n                break;\r\n            case \"devtools\":\r\n                if (!chrome.devtools) throw \"Cannot set context='devtools' when the script is not in a devtools window.\";\r\n                completeScriptId = CONNECTION_PREFIX_NOTAB + this.scriptId + \"-\" + chrome.devtools.inspectedWindow.tabId;\r\n                break;\r\n            case \"tab-agnostic\":\r\n                completeScriptId = this.scriptId;\r\n                break;\r\n        }\r\n\r\n        let port = chrome.runtime.connect(\r\n            {\r\n                name: completeScriptId\r\n            }\r\n        );\r\n\r\n        this.connection = new Connection(port, this.exposedData);\r\n        \r\n        this.connection.addListener(\"disconnect\", () => {\r\n            this.disconnectBackgroundScript();\r\n        });\r\n\r\n        window.addEventListener(\"beforeunload\", () => {\r\n            this.disconnectBackgroundScript();\r\n        });\r\n\r\n        this.fireEvent(\"connected\", {});\r\n    }\r\n\r\n    /**\r\n     * Function to disconnect this script\r\n     */\r\n    disconnectBackgroundScript() {\r\n        if (this.connection) {\r\n            this.connection.disconnect();\r\n        }\r\n\r\n        this.connection = null;\r\n        this.fireEvent(\"disconnected\", {});\r\n    }\r\n\r\n    /**\r\n     * Function to retrieve the connection proxy.\r\n     * \r\n     * @async\r\n     * @return {Promise<Proxy>}\r\n     */\r\n    async getConnection() {\r\n\r\n        if (!this.connection) {\r\n            this.connectBackgroundScript();\r\n        }\r\n\r\n        let proxy = await this.connection.getProxy();\r\n        return proxy;\r\n    }\r\n\r\n    /**\r\n     * Function that returns a uuid version 4 formatted string.\r\n     * \r\n     * @return {string} the id.\r\n     */\r\n    _uuidv4() {\r\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\r\n            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\r\n            return v.toString(16);\r\n        });\r\n    }\r\n}\r\n\r\nexport default BackgroundScript;"],"names":["$65764249770386fea041f92ad6e45b5a$var$asyncGeneratorStep","gen","resolve","reject","_next","_throw","key","arg","info","value","error","done","Promise","then","fn","self","this","args","arguments","apply","err","undefined","obj","Object","defineProperty","enumerable","configurable","writable","$a928baf4ce366f2e3cba84057744df8d$var$extends_","assign","target","i","length","source","prototype","hasOwnProperty","call","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","forEach","$6lnZy","default","excluded","$MeKQR","sourceSymbolKeys","indexOf","propertyIsEnumerable","sourceKeys","arr","$2ob6r","$2nbNe","$12yoO","Array","isArray","iter","Symbol","iterator","toString","from","TypeError","$c7821ac8bf85ae093466d90ef52d7564$export$96e0e44050177ef1","$4xoKp","$c7821ac8bf85ae093466d90ef52d7564$export$c3c55362089d3e17","$5wX0M","$6yLte","exposedData","scriptConnections","Map","errorCallback","options","addListener","port","handleNewConnection","name","scriptId","parsePortName","tabId","sender","tab","id","get","hasTabId","connection","disconnectScript","set","fireEvent","isInternalConnection","startsWith","$5I6CI","CONNECTION_PREFIX","CONNECTION_PREFIX_NOTAB","substr","generateScriptId","conn","$d790af4ba20ef5385a76e77ec09c5858$export$9099ad97b570f7c","listeners","event","callback","callbacksList","push","removeListener","callbackIndex","splice","details","$bba89e9ac323bbd46fff9f6a7aaeca59$export$8408ca23686660f6","$bba89e9ac323bbd46fff9f6a7aaeca59$export$257b00fb1c310327","$bba89e9ac323bbd46fff9f6a7aaeca59$export$8b350cd3497ac931","$bba89e9ac323bbd46fff9f6a7aaeca59$export$ee59c52cd68ef2e3","proxy","nextRequestId","parseExposedData","onMessage","message","handleMessage","data","entries","RESTRICTED_NAMES","includes","exposedMethods","exposedProps","type","initConnection","remoteMethods","handleMessageTypes","postMessage","response","receivedBootstrapInfo","getRequestCallback","result","res","catch","console","initProxy","Proxy","property","getTrap","setTrap","request","_hasMethod","_sendMessage","prop","$6c9ba9993c6605812e0c047d8233574b$export$85c64e8ae011fc6a","getTextCallback","_uuidv4","context","connectBackgroundScript","completeScriptId","chrome","devtools","inspectedWindow","runtime","connect","Connection","disconnectBackgroundScript"],"version":3,"file":"background.86ced2c0.js.map"}